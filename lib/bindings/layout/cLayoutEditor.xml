<?xml version="1.0" encoding="UTF-8"?>
<bindings xmlns="http://www.mozilla.org/xbl" xmlns:xbl="http://www.mozilla.org/xbl">
	<binding id="cLayoutEditor">
		<handlers>
			<handler event="keypress" keycode="VK_F1" phase="capturing" preventdefault="true"><![CDATA[
				this.showBlockInfo();
			]]></handler>

			<!--
			<handler event="keypress" keycode="VK_BACK" preventdefault="true"><![CDATA[
				wCore.debug("<-BACK");
	            event.stopPropagation();
			]]></handler>
			-->
			
			<handler event="keypress" key="s" modifiers="control" preventdefault="true"><![CDATA[
                if (!this._modificationSaved)
                {
                    this.saveContent();
                }
            ]]></handler>
            
		</handlers>
		<implementation>
		
            <method name="getElementById">
                <parameter name="id"/>
                <body><![CDATA[
                    return document.getAnonymousElementByAttribute(this, "anonid", id);
                ]]></body>
            </method>
            
			<property name="scrollBox" readonly="true">
				<getter><![CDATA[
                    var queryInterface = Components.interfaces.nsIScrollBoxObject;
                    var scrollBoxObject = this.getElementById("container").boxObject.QueryInterface(queryInterface);
                    return scrollBoxObject;
                ]]></getter>
			</property>

			<property name="focusedElement">
				<setter><![CDATA[
					/*
					if (this.dragAndDropInProcess)
					{
						return;
					}
					*/
					if (val != undefined)
					{
						if (val != this._focusedElement)
						{
							this.disableResize();
						}
					}
					
					if (val != undefined)
					{	
						this.getElementById('showPropertyGridMenuItem').setAttribute("disabled", true);
						if (this._focusedElement != undefined && this._focusedElement.getAttribute("class") == "focused")
						{
							this._focusedElement.removeAttribute("class");
						}
						this._focusedElement = val;
						val.setAttribute("class", "focused");
						
						if ("refreshContent" in val)
						{
							this.enableRefresh();
						}
						if (this.isBlock(val))
						{
							this.enableResize();
							this.enableInfos();
							if (val.hasPropertyGrid())
							{
								this.getElementById('showPropertyGridMenuItem').removeAttribute("disabled");
							}
						}
						else
						{
							this.disableResize();
							this.disableInfos();
						}
												
						this.updateToolbar(this._focusedElement);
						this.enableDelete();
						
					}
				]]></setter>
				<getter><![CDATA[
					return this._focusedElement;
				]]></getter>
			</property>

			<property name="modificationSaved">
				<setter><![CDATA[
					this.setIsModified(!parseBoolean(val));
				]]></setter>
				<getter><![CDATA[
					return this.isModified;
				]]></getter>
			</property>
			
			

			<field name="_focusedElement">null</field>
			<field name="loadCounter">0</field>
			<field name="isModified">false</field>
			<field name="isLoaded">false</field>

			<constructor><![CDATA[
				try
                {
					this.getPageDeck().setAttribute('selectedIndex', 1);
					this.getPageDeck().setAttribute('editorLoaded', 'true');
					
					this.preLoadBinding('form.cField');	
					this.preLoadBinding('form.cConstraint');
					this.preLoadBinding('core.cRichText');
					this.preLoadBinding('layout.cLayoutToolbars');
					this.preLoadBinding('layout.cRichTextBlockToolbar');
									
					this.hidePropertyGridContainer();
				    //this.registerDragAndDrop(this);
				    
				    this.loadCounter = $("cblock,cfixedblock,clayout,clayoutelement,crichtextblock").length;
				    var xbl = this;
				    var maxExecution = 100;
				    wCore.executeOnPredicate(function(){return (xbl.loadCounter == 0) || (maxExecution-- == 0);}, function(){xbl.onEditorLoaded();});
		            this.initBlockList();
	                this.enableSaveTemplate();
	                
	
	                var container = this.getElementById("container");
	                container.addEventListener("keypress", function(event){event.preventDefault();event.stopPropagation();}, true);
	            } 
	            catch (e)
	            {
	            	wCore.error("cLayoutEditor.constructor", [], e);
	            }
			]]></constructor>
			
			<method name="preLoadBinding">
				<parameter name="src" />
				<body><![CDATA[
					try
					{
						wCore.debug('preLoadBinding : ' + src);
						var baseBindingurl = Context.CHROME_BASEURL + '/module=uixul&action=GetBinding&binding=' + src +'&uilang=' + Context.W_UILANG;
						return document.loadBindingDocument(baseBindingurl);
					}
					catch (e)
					{
						wCore.error('preLoadBinding', [src], e);
					}
					return null;
				]]></body>
			</method>				
			<method name="getServerRequestModule">
				<body><![CDATA[
					if (this.hasAttribute('serverRequestModule'))
					{
						return this.getAttribute('serverRequestModule');
					}
					return 'website';
				]]></body>
			</method>			
			
			<method name="enableSaveTemplate">
				<body><![CDATA[
					if (wCore.checkPermission('modules_website.WizardSaveAsTemplate', pageData.id.toString()))
					{
						this.getElementById('saveTemplateButton').removeAttribute("collapsed");
					}
				]]></body>
			</method>
			
			<method name="initBlockList">
				<body><![CDATA[
					var inDashboard = (this.getServerRequestModule() == 'dashboard');
					var element = this.getElementById('blocksLayoutPopup');
					var selected = null;
					var controller = getController();
					
				   	for (var i = 0; i < element.childNodes.length; i++)
                    {	
                    	var menuitem = element.childNodes[i];
                    	if (menuitem.tagName == 'menuitem')
                    	{
                    		if (controller.checkModuleAsRessource(menuitem.getAttribute('wmodule')))
                    		{
	                    		var dashboarditem = menuitem.hasAttribute('dashboard');
	                    		if ((dashboarditem && inDashboard) || (!dashboarditem && !inDashboard))
	                    		{
	                    			menuitem.removeAttribute('collapsed');
	                    			if (selected == null)
	                    			{
	                    				selected = menuitem;
	                    			}
	                    		}
	                    		else
	                    		{
	                    			menuitem.setAttribute('collapsed', 'true');
	                    		}                    			
                    		}
                    		else
                    		{
                    			menuitem.setAttribute('hidden', 'true');
                    		}
                    	}
                    }
                    if (selected != null)
                    {
                    	selected.doCommand();
                    }
				]]></body>
			</method>
			
			<method name="onEditorElementDeleted">
				<body><![CDATA[
				    this.focusedElement = null;
					this.disableDelete();
					this.disableInfos();
					this.disableResize();
					this.disableRefresh();
					this.updateToolbar(null);
					this.hidePropertyGridContainer();
				]]></body>
			</method>

			<method name="onEditorLoaded">
				<body><![CDATA[
					if (this.loadCounter != 0)
					{
						wCore.debug("all editor components did not report as loaded, enabling save anyway");
					}
					this.isLoaded = true;
					this.getElementById("saveButton").removeAttribute("disabled");
				]]></body>
			</method>
			
			<field name="_temporaryIdCounter">0</field>
			<method name="getTemporaryId">
				<body><![CDATA[
					this._temporaryIdCounter ++;
					
					return "TMP_" + this._temporaryIdCounter;
				]]></body>				
			</method>

			<method name="initializeChangeContent">
				<parameter name="contentElement" />
				<body><![CDATA[
					var div = document.createElement("vbox");
					div.setAttribute("id", contentElement.getAttribute("id"));
					var dropzone = document.createElement('clayoutdropzone');
					dropzone.setAttribute("type", "bottom");
					dropzone.setAttribute("flex", "1");
					$(contentElement).before(div);
					$(div).append(dropzone);
					var xbl = this;
					$(contentElement).children("changelayout").each(function(i){
						xbl.initializeChangeLayout(this, div)
					});
					$(contentElement).remove();
				]]></body>
			</method>

			<method name="initializeChangeLayout">
				<parameter name="layoutElement" />
				<parameter name="parentElement" />
				<body><![CDATA[
					var clayout = document.createElement("clayout");
					var columnCount = $(layoutElement).children("changecol").length;
					clayout.setAttribute("columnCount", columnCount);
					$(parentElement).append(clayout);
					var newDropzone = document.createElement('clayoutdropzone');
          			newDropzone.setAttribute("type", "bottom");
          			$(parentElement).append(newDropzone);
					$("changecol", clayout).each(function(i)
					{
						
					});
				]]></body>
			</method>

			<method name="setIsModified">
				<parameter name="value" />
				<body><![CDATA[
    				this.isModified = value;
    				var saveButton = this.getElementById("saveButton");
    				if (this.isModified)
    				{
    					if (this.isLoaded)
    					{
    						saveButton.removeAttribute("disabled");
    					}
    				}
    				else
    				{
    				   	saveButton.setAttribute("disabled", "true");
    				}
    			 ]]></body>
			</method>


			<method name="setToolbarByElement">
				<parameter name="element" />
				<body><![CDATA[
					if (element.getToolbarType() == undefined)
					{
						return;
					}
					var blockToolbar = this.getElementById("blocktoolbar");
					var toolbar = document.createElement(element.getToolbarType());
					if (element.getToolbarType() == "wblocktoolbar")
					{
						toolbar.setAttribute("type", element.getBlockType());
					}
					var xbl = this.focusedElement;
					blockToolbar.appendChild(toolbar);	
					wCore.executeLater(function(){if("initialize" in toolbar) toolbar.initialize(xbl);}, 100);
				]]></body>
			</method>

			<method name="updateToolbar">
				<parameter name="element">
					<body><![CDATA[				
					var blockToolbar = this.getElementById("blocktoolbar");
					if (blockToolbar.lastChild != undefined)
					{
						blockToolbar.removeChild(blockToolbar.lastChild);
					}
					if (element != undefined && "getToolbarType" in element)
					{			
						this.setToolbarByElement(element);
					}
				]]></body>
				</parameter>
			</method>

			<method name="enableDelete">
				<body><![CDATA[
					this.getElementById("delete").removeAttribute("disabled");
                 ]]></body>
			</method>

			<method name="disableDelete">
				<body><![CDATA[
					this.getElementById("delete").setAttribute("disabled", "true");
                 ]]></body>
			</method>

			<method name="enableRefresh">
				<body><![CDATA[
					this.getElementById("refresh").removeAttribute("disabled");
                 ]]></body>
			</method>

			<method name="disableRefresh">
				<body><![CDATA[
					this.getElementById("refresh").setAttribute("disabled", "true");
                 ]]></body>
			</method>

			<method name="enableResize">
				<body><![CDATA[
    		 		var textBox = this.getElementById("widthTextbox");
    		 		textBox.removeAttribute("collapsed");
					textBox.removeAttribute("disabled");
					if (this.focusedElement != undefined && this.focusedElement.hasAttribute("blockwidth"))
					{
						textBox.value = this.focusedElement.getAttribute("blockwidth");
					}
                 ]]></body>
			</method>

			<method name="disableResize">
				<body><![CDATA[
    		 		var textBox = this.getElementById("widthTextbox");
					textBox.setAttribute("disabled", "true");
					textBox.value = "";
					textBox.setAttribute("collapsed", "true");
                 ]]></body>
			</method>

			<method name="enableInfos">
				<body><![CDATA[
    		 		var textBox = this.getElementById("block-info");
					textBox.removeAttribute("disabled");
                 ]]></body>
			</method>

			<method name="disableInfos">
				<body><![CDATA[
    		 		var textBox = this.getElementById("block-info");
					textBox.setAttribute("disabled", "true");
                 ]]></body>
			</method>

			<method name="deleteFocusedElement">
				<body><![CDATA[
					if (this.focusedElement != undefined && "delete" in this.focusedElement)
					{
						this.focusedElement.markedForDeletion = true;
						if (window.confirm("&modules.uixul.bo.general.Confirmdeletemessage;"))
						{
							this.focusedElement.delete();
							this.setIsModified(true);
						}
						else
						{
							this.focusedElement.markedForDeletion = false;
						}
					}
					else
					{
						wCore.error("can not delete element");
					}
				]]></body>
			</method>

			<method name="refreshFocusedElement">
				<body><![CDATA[
					if (this.focusedElement != undefined && "refreshContent" in this.focusedElement)
					{
						this.focusedElement.refreshContent();
					}
					else
					{
						wCore.error("can not refresh");
					}
				]]></body>
			</method>

			<!--  PROPRTY GRID -->
			<method name="getPropertyGridContainer">
				<body><![CDATA[
					return this.getElementInParentModule('propertyGridContainer');
            	]]></body>
			</method>

			<method name="getPropertyGridContainerSplitter">
				<body><![CDATA[
					return this.getElementInParentModule('propertyGridContainerSplitter');
            	]]></body>
			</method>

			<method name="getPageDeck">
				<body><![CDATA[
					return this.getElementInParentModule('pageDeck');
            	]]></body>
			</method>
			
			<method name="getElementInParentModule">
				<parameter name="elementName" />
				<body><![CDATA[
					var moduleName = this.getServerRequestModule();
					var pm = parent.document.getElementById('wmodule_' + moduleName);
					if (!elementName) {return pm;}

					if ('getElementByAnonId' in pm)
					{
						return pm.getElementByAnonId(elementName);
					}
            		return pm.getElementById(elementName);
            	]]></body>
			</method>			

			<method name="hidePropertyGridContainer">
				<body><![CDATA[
            		this.getPropertyGridContainer().hide();
            	]]></body>
			</method>

			<method name="showPropertyGridContainer">
				<body><![CDATA[
            		this.getPropertyGridContainer().show();
            	]]></body>
			</method>
			
			<method name="showPropertyGridForCurrentBlock">
				<body><![CDATA[
					if (!this.isBlock(this.focusedElement))
					{
						return;
					}
					if (!this.focusedElement.hasPropertyGrid())
					{
						return;
					}
            		this.setPropertyGridForBlock(this.focusedElement);
            	]]></body>
			</method>

			<method name="setPropertyGridForBlock">
				<parameter name="block" />
				<body><![CDATA[
                	this.getPropertyGridContainer().showPropertyGridForBlock(block);
                ]]></body>
			</method>


			<!--  end property grid -->
			<method name="backToDataEditing">
				<body><![CDATA[
                    try
                    {
                        var controller = getController();
                        if (parent && parent.document && this.getPageDeck() && controller && !controller.isBusy)
                        {                        
                            if ((this.isModified == false) || window.confirm("&modules.uixul.bo.general.form.Confirmloosemodifications;"))
                            {
                            	if (this.getServerRequestModule() == 'dashboard')
                            	{
                            		parent.document.getElementById('wmodule_dashboard').onLoadAction();	
                            	}
                            	else
                            	{
									this.getElementInParentModule(null).refreshFromEditor();									
	                              	this.hidePropertyGridContainer();
	                            }
                            }
                        }
                    }
                    catch (e)
                    {
                       wCore.error("cLayoutEditor.backToDataEditing", [], e);
                    }
                ]]></body>
			</method>

			<method name="toggleBlockList">
				<parameter name="forceOpen" />
				<body><![CDATA[
                    try
                    {
                        var blockList = this.getElementById('tablist');

                        var element = this.getElementById('blockListToggle');

                        if (blockList.hasAttribute("collapsed") || forceOpen)
                        {
                            blockList.removeAttribute("collapsed");
                            element.checked = true;
                        }
                        else
                        {
                            blockList.setAttribute("collapsed", "true");
                            element.checked = false;
                        }
                    }
                    catch (e)
                    {
                        wCore.error("cLayoutEditor.toggleBlockList", [forceOpen], e);
                    }
                ]]></body>
			</method>

			<method name="saveContent">
				<body><![CDATA[
				
					this.getElementById("saveButton").setAttribute("disabled", "true");
					this.getElementById("backButton").setAttribute("disabled", "true");
					try
					{
						content = this.getXMLContentString();
						if (content.length > 8000000)
                   		{
                    		alert("&modules.uixul.bo.layout.Warning-content-too-long;");
                    		return;
                    	}
                    	var module = this.getServerRequestModule()
                    	
                    	var attributes = {cmpref: pageData.id, 
                    		lang: pageData.lang, 
                    		documentversion: pageData.documentversion,
                    		content: content
                    	};
                    	
                    	var result = wCore.executeJSON(module, 'SaveContent', attributes, null, true);
                    	
						if (result.status != 'OK')
						{
                    		var message = new wLocale("&modules.uixul.bo.layout.SaveError;");
                            message.setAttribute("error", result.contents.errorMessage);
                            alert(message.toString());
                        }
 						else
 						{
 							pageData.id = result.contents.id;
 							pageData.lang = result.contents.lang;
 							pageData.documentversion = result.contents.documentversion;
							this.setIsModified(false);
 						}
 					} 
 					catch(e)
 					{
 						wCore.error("cLayoutEditor.saveContent", [], e);
 					}
 					this.getElementById("saveButton").removeAttribute("disabled");
 					this.getElementById("backButton").removeAttribute("disabled");
				]]></body>
			</method>

			<method name="getXMLContentString">
				<body><![CDATA[
					var xmlData = new XML('<change:contents xmlns:change="http://www.rbs.fr/change/1.0/schema" ></change:contents>');
					var xmlDomData = document.createElementNS("http://www.rbs.fr/change/1.0/schema", "change:contents");
					var xbl = this;
					$("clayoutdropzone").parent().each(function(i){ 
						xbl.processChangeContent(this, xmlDomData);
					}); 
					var oldFormatting = XML.prettyPrinting;					
					XML.prettyPrinting = false;
					var dataString = (new XMLSerializer()).serializeToString(xmlDomData)
					XML.prettyPrinting = oldFormatting;
					return dataString;
				]]></body>
			</method>

			<method name="processChangeContent">
				<parameter name="parentElement" />
				<parameter name="xmlData" />
				<body><![CDATA[
					var xbl = this;					
					var content = document.createElementNS("http://www.rbs.fr/change/1.0/schema", "change:content");
					content.setAttribute("id", parentElement.getAttribute("id"));
					//var content = <change:content xmlns:change="http://www.rbs.fr/change/1.0/schema"  id={parentElement.getAttribute("id")} />;
					$(parentElement).contents().filter("clayout").each(function(i){
						content.appendChild(this.getXMLContent());
					});
					xmlData.appendChild(content);
					$("block", xmlData).each(function(i){
						this.setAttributeNS("http://www.rbs.fr/change/1.0/schema", "change:blockId", ""+i);
					});
					
				]]></body>
			</method>

			<method name="cleanDropzones">
				<parameter name="container" />
				<parameter name="dropZoneType" />
				<body><![CDATA[
					if (container == undefined)
					{
						container = this;
					}
					if (dropZoneType == undefined)
					{
						dropZoneType = 'cdropzone';
					}
            		var toDelete = false;
            		var currentNode = container.firstChild;
            		while (currentNode != undefined)
            		{
            			var nextNode = currentNode.nextSibling;
            			if (currentNode.tagName == dropZoneType)
            			{
            				if (toDelete)
            				{	
            					container.removeChild(currentNode);
            				}
            				else
            				{
            					toDelete = true
            				}
            			}
            			else
            			{
            				toDelete = false;
            			}
            			currentNode = nextNode;
            		}
            		if (container.lastChild != undefined)
            		{
            			container.lastChild.flex = 1;
            		}
            	]]></body>
			</method>
		
			<!-- COMPAT/OLD METHODS -->
			<method name="setBlockAttribute">
				<parameter name="attribute" />
				<parameter name="parameter" />
				<parameter name="value" />
				<body><![CDATA[
                    try
                    {
                        this.focusedElement.setBlockAttribute(attribute, parameter, value);
                        this.setIsModified(true);
                    }
                    catch (e)
                    {
                        wCore.error("cLayoutEditor.setBlockAttribute", [attribute, parameter, value], e);
                    }
                ]]></body>
			</method>

			<method name="unimplementedAlert">
				<body><![CDATA[	
					alert("Cette fonctionnalité n'est pas encore implementée");
				]]></body>
			</method>

			<method name="openPreview">
				<body><![CDATA[
                    //this.unimplementedAlert();
                    try
                 	{
                    	var controller = getController();
                        var content = this.getXMLContentString();
                        var url = "{HttpHost}/xul_controller.php?module=website&action=PreviewPage";
                        var pageData = getCurrentPageData();
                        url = url + '&cmpref=' + pageData.id.toString();
                        url = url + '&lang=' + pageData.lang.toString();
                        p = new XMLHttpRequest();
                        p.onload = null;
                        p.open("POST", url, false);
                        p.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
                        p.send("content=" + encodeURIComponent(content));
                        var previewUrl = "about:blank";
                        var e4x = controller.getXmlObjectFromResponse(p.responseText);
                        if (e4x.message.toString() != '')
                        {
                            previewUrl = e4x.message.toString();
                        }
                        
                        var previewFrame = this.getElementInParentModule('previewFrame');
                        if (previewFrame)
                        {
                            previewFrame.setAttribute("src", previewUrl);
                            this.getPageDeck().setAttribute("selectedIndex", 2);
                            var rscTree =  this.getElementInParentModule(null).getRessourcesSelector();  
                            if (rscTree && !rscTree.hasAttribute("collapsed"))
                            {
                            	this._hasToOpenRscTree = true;
                            	rscTree.setAttribute("collapsed", "true");
                            }
                        }
                        else
                        {
                            var left = Math.floor( (screen.width - 800) / 2);
                            var top = Math.floor( (screen.height - 600) / 2);
                            window.open(previewUrl, "Preview", "menubar=no, toolbar=no, location=no, resizable=yes, scrollbars=yes, status=yes, top=" + top + ", left=" + left + ", height=600, width=800");
                        }
                    }
                    catch (e)
                    {
                    	wCore.error("cLayoutEditor.openPreview", [], e);
                    }
                ]]></body>
			</method>

			<method name="isBlock">
				<parameter name="element" />
				<body><![CDATA[
					return (element.tagName == "cblock" || element.tagName == "crichtextblock" || element.tagName == "cemptyblock");
				]]></body>
			</method>

			<method name="showBlockInfo">
				<body><![CDATA[
                	if (this.focusedElement && this.isBlock(this.focusedElement))
                    {
                    	var infos = {};
                        var block = this.focusedElement;
                        infos.type = block.getBlockType();
                         
                        infos.references =  block.getPersistentDocumentId();

                        infos.configuration = block.getDisplay();
		
						if (block.hasAttribute("blockwidth"))
                     	{
                     		infos.width = block.getAttribute("blockwidth");
                     	} 
                     	else
                      	{
                      		infos.width = block.getRelativeFrontOfficeWidth();
                      	}

                     	if (block.type == "richtext")
                      	{
                    		infos.content = block.getRichtextContent();
                      	}
                      	
						wToolkit.setDialogParam(infos);
						wToolkit.dialog("website", "InfoBlock", {cmp: block.type}, {height: "400px"}, true);
                  	}
                ]]></body>
			</method>
			

            <field name="_hasToOpenRscTree" readonly="false">false</field>
            
            <method name="backToContentEditing">
                <body><![CDATA[
                    try
                    {
                    	if (this._hasToOpenRscTree)
                    	{
                    		this._hasToOpenRscTree = false;
                    		var rscTree = this.getElementInParentModule(null).getRessourcesSelector();
                    		rscTree.removeAttribute("collapsed");
                    	}
                    }
                    catch (e)
                    {
                        wCore.error("cLayoutEditor.backToContentEditing", [], e);
                    }
                ]]></body>
            </method>
			
			<method name="saveTemplate">
                <body><![CDATA[
                    try
                    {
                        var pageData = getCurrentPageData();
                        getController().openModalDialog(this, "savetemplate", pageData);                  
                    }
                    catch (e)
                    {
                        wCore.error("cLayoutEditor.saveTemplate", [], e);
                    }
                ]]></body>
            </method>
            
            <method name="performSaveTemplate">
            	<parameter name="values" />
	            <body><![CDATA[
	            try
	            {
                    var parameters = {};
                    parameters.label = values.label;
                    parameters.description = values.description;
                    parameters.pageid = values.id;
                    parameters.content = this.getXMLContentString();;
                    parameters.lang = values.lang.toString();
                    
                    //wCore.debug("performSaveTemplate: " + wCore.dump(parameters));
                    var me = this;
                    var callBack = function(result) {me.onTemplateSaved(result);}
                    wCore.executeJSON('website', 'SaveTemplate', parameters, callBack, true);
                }
                catch (e)
                {
                    wCore.error("cLayoutEditor.performSaveTemplate", [values], e);
                }
	            ]]></body>
            </method>
            
            <method name="onTemplateSaved">
				<parameter name="result" />
				<body><![CDATA[
					if (result.status == 'OK')
					{
						window.alert("&amp;modules.uixul.bo.layout.SaveTemplate-success;");
					}
					else
					{
						window.alert("&amp;modules.uixul.bo.layout.SaveTemplate-error;");
					}
				]]></body>
            </method>
            
            <method name="onSelectBlockDeck">
				<parameter name="deckIndex" />
				<body><![CDATA[
				   var menuItem = this.getElementById("blocksLayoutMenu_" + deckIndex);
				   var button = this.getElementById("blocksLayoutButton");
				   button.setAttribute("label", menuItem.getAttribute("label"));
				   button.setAttribute("image", menuItem.getAttribute("image"));
				   var layoutDeck = this.getElementById("blocksLayoutDeck");
				   layoutDeck.selectedIndex = deckIndex;
				   layoutDeck.removeAttribute('hidden');			
				]]></body>
            </method>
		</implementation>

		<xbl:content xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul">
			<vbox flex="1">
				<toolbox orient="vertical" class="change-toolbox">
					<toolbar anonid="editorToolbar" flex="1" class="change-toolbar">
						<toolbarbutton anonid="backButton" image="{HttpHost}/icons/small/previous.png" label="&amp;modules.uixul.bo.layout.BackToDataEditing;"
							tooltiptext="&amp;modules.uixul.bo.layout.BackToDataEditing-help;" oncommand="backToDataEditing();" xbl:inherits="hidden=hiddenback"/>
						<toolbarseparator />
						<toolbarbutton anonid="saveButton" disabled="true" image="{HttpHost}/icons/small/save.png" label="&amp;modules.uixul.bo.layout.SaveContent;"
							oncommand="saveContent();" />
						<toolbarbutton collapsed="true" anonid="saveTemplateButton" image="{HttpHost}/icons/small/template.png" label="&amp;modules.uixul.bo.layout.SaveTemplate;"
							oncommand="saveTemplate();" xbl:inherits="hidden=hiddensavetemplate"/>
						<toolbarseparator />
						<toolbarbutton image="{HttpHost}/icons/small/preview.png" label="&amp;modules.uixul.bo.layout.PreviewContent;" oncommand="openPreview();" xbl:inherits="hidden=hiddenpreview"/>
						<toolbarspacer flex="1" />
					</toolbar>
				</toolbox>
				<toolbox orient="horizontal" class="change-toolbox-light">
					<toolbar anonid="basicToolbar" class="change-toolbar">
						<toolbarbutton anonid="delete" image="{HttpHost}/icons/small/delete.png" tooltiptext="&amp;modules.uixul.bo.layout.DeleteBlock;"
							oncommand="deleteFocusedElement();" disabled="true" />
						<toolbarbutton anonid="refresh" image="{HttpHost}/icons/small/refresh.png" tooltiptext="&amp;modules.uixul.bo.layout.RefreshBlock;"
							oncommand="refreshFocusedElement();" disabled="true" />
						<toolbarseparator />
						<toolbaritem align="center">
							<textbox id="width" anonid="widthTextbox" size="10" onchange="setBlockAttribute('blockwidth', null, this.value);" disabled="true"
								tooltiptext="&amp;modules.uixul.bo.layout.BlockWidth-help;" />
						</toolbaritem>
					</toolbar>
					<box anonid="blocktoolbar" />
				</toolbox>
				<scrollbox flex="1" anonid="container" class="dashed-container" style="overflow: auto; border-top: 1px solid #999;">
					<xbl:children />
				</scrollbox>
				<vbox anonid="blockList" class="blockList">
					<toolbox>
						<toolbar>
						    <toolbarbutton anonid="blocksLayoutButton" image="{HttpHost}/icons/small/modules.png" type="menu">
								<menupopup anonid="blocksLayoutPopup">{BLOCKTABS}</menupopup>
							</toolbarbutton>
						</toolbar>
					</toolbox>
					<deck anonid="blocksLayoutDeck" flex="1">{BLOCKPANELS}</deck>
				</vbox>
				<popupset>
					<menupopup id="blockbasepopup">
						<menuitem class="menuitem-iconic" label="&amp;modules.uixul.bo.layout.DeleteBlock;" image="{HttpHost}/icons/small/delete.png" oncommand="deleteFocusedElement();" />
						<menuitem class="menuitem-iconic" label="&amp;modules.uixul.bo.layout.ShowPropertyGrid;" image="{HttpHost}/icons/small/edit.png" anonid="showPropertyGridMenuItem" oncommand="showPropertyGridForCurrentBlock();"/>
						<menuitem class="menuitem-iconic" image="{HttpHost}/icons/small/refresh.png" label="&amp;modules.uixul.bo.layout.RefreshBlock;" oncommand="refreshFocusedElement();"  />
						<menuitem class="menuitem-iconic" anonid="block-info" image="{HttpHost}/icons/small/information.png" label="&amp;modules.uixul.bo.layout.InfoBlock;" oncommand="showBlockInfo();"  />
					</menupopup>
				</popupset>
			</vbox>
		</xbl:content>
	</binding>
	
	<binding id="cEditorElement" extends="core.wBox#wBox">
		<implementation>
			<field name="_layoutEditor">null</field>
			
			<property name="layoutEditor">
				<getter><![CDATA[ 
    				return this.getLayoutEditor();
    			]]></getter>
			</property>
			
			<constructor><![CDATA[
				this.getLayoutEditor(); 				
    		]]></constructor>
    		
    		<method name="getLayoutEditor">
    			<body><![CDATA[
					if (this._layoutEditor == undefined)
    				{
    					var parent = this.parentNode;
						while (parent != undefined)
						{
							if (parent.tagName == "clayouteditor")
							{
								this._layoutEditor = parent;
								break;
							}	
							parent = parent.parentNode;
						}
    				} 
    				return this._layoutEditor;
				]]></body>
    		</method>
			
			<method name="setIsLoaded">
				<body><![CDATA[
					this.layoutEditor.loadCounter--;
				]]></body>
			</method>
			
			<method name="cleanDropzones">
				<parameter name="container" />
				<parameter name="dropZoneType" />
				<body><![CDATA[
					if (container == undefined)
					{
						container = this;//$("[@anonid=container]", this).get(0);//this.getElementById("container");
					}
					if (dropZoneType == undefined)
					{
						dropZoneType = 'cdropzone';
					}
            		var toDelete = false;
            		var currentNode = container.firstChild;
            		while (currentNode != undefined)
            		{
            			var nextNode = currentNode.nextSibling;
            			if (currentNode.tagName == dropZoneType)
            			{
            				if (toDelete)
            				{	
            					container.removeChild(currentNode);
            				}
            				else
            				{
            					toDelete = true
            				}
            			}
            			else
            			{
            				toDelete = false;
            			}
            			currentNode = nextNode;
            		}
            		if (container.lastChild != undefined)
            		{
            			container.lastChild.flex = 1;
            		}
            	]]></body>
			</method>
			
			<method name="getPixelValueAsInt">
				<parameter name="value" />
				<body><![CDATA[
					if (typeof value == 'string')
					{
						var lastIndex = value.lastIndexOf("px");		
						if (lastIndex > 0)
						{
							return parseInt(value.substring(0, lastIndex));
						}
					}
					return value;
				]]></body>
			</method>
			
			<method name="onDragOver">
                <parameter name="element"/>
                <parameter name="data"/>
                <body><![CDATA[
               		this.ensureDragAndDropUsability(this.layoutEditor.getElementById('container'));
                ]]></body>
            </method>		
		</implementation>
	</binding>
	
	<binding id="cBlockBase" extends="layout.cLayoutEditor#cEditorElement">
		<handlers>
			<handler event="focus"><![CDATA[
                event.stopPropagation();
            ]]></handler>

			<handler event="blur"><![CDATA[
                event.stopPropagation();
            ]]></handler>

			<handler event="click" clickcount="2" button="0" preventdefault="true" phase="capturing"><![CDATA[
				 event.stopPropagation();
				 if (this.hasPropertyGrid())
				 {
				 	this.layoutEditor.setPropertyGridForBlock(this);
				 }
			]]></handler>
			
			<handler event="click" button="0" preventdefault="true" phase="capturing"><![CDATA[
				 event.stopPropagation();
			]]></handler>
			
		</handlers>

		<implementation>
			<!-- fields -->
			<field name="assignedWidthInPixels">0</field>
			<field name="markedForDeletion">false</field>
			<field name="maxAllowedWidth">0</field>
			<field name="blockParameters">{ }</field>
			<field name="backupDisplayData">null</field>

			<field name="BLOCK_BOX_X_OFFSET" readonly="true"><![CDATA[
                -32
            ]]></field>

			<field name="BLOCK_BOX_Y_OFFSET" readonly="true"><![CDATA[
                -128
            ]]></field>
			<!-- properties -->
			<property name="block">
				<getter><![CDATA[
                    return this;
                ]]></getter>
			</property>
			<!-- properties -->
			<property name="editor">
				<getter><![CDATA[
                    return this.layoutEditor;
                ]]></getter>
			</property>
			<property name="type">
				<getter><![CDATA[
                    return this.getBlockType();
                ]]></getter>
			</property>

			<constructor><![CDATA[
				this.removeAttribute("width");
				this.setBlockType(this.getAttribute('type'));
				if (this.isEditable())
		        {
    				this.setAttribute("candrag", "true");
    				this.setAttribute("candrop", "layout/block document/block");
    				this.registerDragAndDrop(this);
    			}
    			else
    			{
    				this.getElementById("container").removeAttribute("context");
    			}
    			if ($(this).next("cblock,crichtextblock,cemptyblock").length > 0)
		        {
		         	this.hideRightDropZone();
		       	}
		       	else
		       	{
		       		this.showRightDropZone();
		       	}
    			this.initialize();
    		]]></constructor>
			
			<method name="setDefaultContent">
				<body><![CDATA[
					var element = document.createElement("label");
		        	element.setAttribute("class", "block-loading");
		        	element.setAttribute("value", "&modules.uixul.bo.layout.loadingBlock;");
		        	this.setContent(element);
				]]></body>
			</method>
			
			<method name="isEditable">
				<body><![CDATA[
					if (!this.hasAttribute("editable"))
					{
						return true;
					}
					return parseBoolean(this.getAttribute("editable"));
               	]]></body>
			</method>

			<method name="setIsFocused">
				<parameter name="state" />
				<body><![CDATA[
                	if (state == true)
                	{
                    	this.layoutEditor.focusedElement = this;
                    }
                    else
                    {
                    	this.layoutEditor.focusedElement = null;
                    }
                ]]></body>
			</method>

			<method name="getParentLayoutElement">
				<body><![CDATA[
				 	var parent = this.parentNode;
					while (parent != undefined)
					{
						if (parent.tagName == "clayoutelement")
						{
							return parent;
						}
						parent = parent.parentNode;
					}
					return null;
               	]]></body>
			</method>

			<method name="getContent">
				<body><![CDATA[
    			    return this.firstChild;
    			]]></body>
			</method>

			<method name="getContentWidth">
				<body><![CDATA[
					return null;
				]]></body>
			</method>

			<method name="getContentWidthAsInt">
				<body><![CDATA[
					return this.getPixelValueAsInt(this.getContentWidth());
				]]></body>
			</method>

			<method name="getWidth">
				<body><![CDATA[
					return this.style.width;
				]]></body>
			</method>

			<method name="getWidthAsInt">
				<body><![CDATA[
					return this.getPixelValueAsInt(this.getWidth());
				]]></body>
			</method>

			<method name="setContent">
				<parameter name="element" />
				<body><![CDATA[
					var container = this;
					if (container.firstChild != undefined)
					{
						container.removeChild(container.firstChild);
					}
    			    container.appendChild(element);
    			]]></body>
			</method>

			<method name="hasContent">
				<body><![CDATA[
					return this.childNodes.length > 0;
    			]]></body>
			</method>

			<method name="getRightDropZone">
				<body><![CDATA[
    			    return this.getElementById("rightDropZone");
    			]]></body>
			</method>

			<method name="getLeftDropZone">
				<body><![CDATA[
    			    return this.getElementById("leftDropZone");
    			]]></body>
			</method>

			<method name="getTopDropZone">
				<body><![CDATA[
					var parentNode = this.parentNode;
					if (parentNode == undefined)
					{
						return null; 
					}
					if (parentNode.previousSibling && parentNode.previousSibling.tagName == "cdropzone")
					{
						return parentNode.previousSibling;
					}
					return null;
				]]></body>
			</method>

			<method name="getBottomDropZone">
				<body><![CDATA[
					var parentNode = this.parentNode;
					if (parentNode == undefined)
					{
						return null; 
					}
					if (parentNode.nextSibling && parentNode.nextSibling.tagName == "cdropzone")
					{
						return parentNode.nextSibling;
					}
					return null;
				]]></body>
			</method>

			<method name="hideRightDropZone">
				<parameter name="zoneId" />
				<body><![CDATA[
           			this.hideDropZoneById('rightDropZone');
           			this.resize(this.assignedWidthInPixels, null);
           		]]></body>
			</method>

			<method name="hideLeftDropZone">
				<parameter name="zoneId" />
				<body><![CDATA[
           			this.hideDropZoneById('leftDropZone');
           			this.resize(this.assignedWidthInPixels, null);
           		]]></body>
			</method>

			<method name="showRightDropZone">
				<parameter name="zoneId" />
				<body><![CDATA[
           			this.showDropZoneById('rightDropZone');
           		]]></body>
			</method>

			<method name="hideDropZoneById">
				<parameter name="zoneId" />
				<body><![CDATA[
           			var child = this.getElementById(zoneId);
           			if (child != undefined)
           			{
           			    wCore.executeOnMethodExists(child, "hide", function(xbl){xbl.hide();});           			
           			}
           		]]></body>
			</method>

			<method name="showDropZoneById">
				<parameter name="zoneId" />
				<body><![CDATA[
           			var child = this.getElementById(zoneId);
           			if (child != undefined)
           			{
           				wCore.executeOnMethodExists(child, "show", function(xbl){xbl.show();});
           			}
           		]]></body>
			</method>

			<method name="removeFromDOM">
				<body><![CDATA[
					this.setIsFocused(false);
					var parentHbox = this.parentNode;
					var parentLayoutElement = this.getParentLayoutElement();
					parentHbox.removeChild(this);
					if (parentHbox.childNodes.length == 0)
					{
						parentHbox.parentNode.removeChild(parentHbox);
						if (parentLayoutElement != undefined)
						{
							parentLayoutElement.cleanDropzones();
							parentLayoutElement.deleteIfEmpty();
						}
					}
					else
					{
						parentHbox.lastChild.showRightDropZone();
						if (parentLayoutElement != undefined)
						{
							parentLayoutElement.resizeBlocksInHbox(parentHbox);
						}
					}
				]]></body>
			</method>

			<method name="delete">
				<body><![CDATA[
					this.layoutEditor.onEditorElementDeleted();
					this.removeFromDOM();
                ]]></body>
			</method>

			<method name="isFocused">
				<body><![CDATA[
					return this.layoutEditor.focusedElement == this;
				]]></body>
			</method>

			<method name="onFocus">
				<parameter name="event" />
				<body><![CDATA[
					if (!this.isEditable() || this.markedForDeletion )
					{
						return;
					}
					if (!this.isFocused() && this.dragAndDropInProcess)
					{
						this.layoutEditor.scrollBox.scrollTo(this.boxObject.x+this.BLOCK_BOX_X_OFFSET, this.boxObject.y+this.BLOCK_BOX_Y_OFFSET);
					}
                	this.setIsFocused(true);   
                	if (this.hasPropertyGrid())
                	{
                		this.displayPropertyGridTooltip();
                	}
                ]]></body>
			</method>

			<method name="displayPropertyGridTooltip">
				<body><![CDATA[
					if (!this.dragAndDropInProcess)
					{
                		var popup = this.getElementById("propertyGridTooltip");
                		var scrollBox = this.layoutEditor.getElementById("container");
                		popup.showPopup(scrollBox, scrollBox.boxObject.screenX , scrollBox.boxObject.screenY-20, 'tooltip', 'topleft'  , 'topleft');      
                		setTimeout(function(){popup.hidePopup();}, 3000);
                	} 
				]]></body>
			</method>

			<method name="hasPropertyGrid">
				<body><![CDATA[
					return this.layoutEditor.getPropertyGridContainer().hasPropertyGrid(this);
                ]]></body>
			</method>

			<method name="showPropertyGrid">
				<body><![CDATA[
				if (this.hasPropertyGrid())
				{
					this.layoutEditor.getPropertyGridContainer().showPropertyGridForBlock(this);
                }
                ]]></body>
			</method>

			<method name="onBlur">
				<parameter name="event" />
				<body><![CDATA[
					if (!this.isEditable())
					{
						return;
					}
                   	this.setIsFocused(false);
                ]]></body>
			</method>

			<method name="initDragData">
				<body><![CDATA[
                        var dragData = [
                            {
                                flavour: "layout/block",
                                data: this
                            }
                        ];
                        return dragData;
                ]]></body>
			</method>

			<method name="setBlockType">
				<parameter name="typeString" />
				<body><![CDATA[
					this.setAttribute("type", typeString);
				]]></body>
			</method>

			<method name="getBlockType">
				<body><![CDATA[
					return this.getAttribute("type");
				]]></body>
			</method>

			<method name="setParametersFromDisplayString">
				<parameter name="displayString" />
				<body><![CDATA[
					this.setParameters(assocStringToObject(displayString));
				]]></body>
			</method>

			<method name="setParameters">
				<parameter name="parameters" />
				<body><![CDATA[
					this.blockParameters = parameters;
				]]></body>
			</method>

			<method name="getParameters">
				<body><![CDATA[
					return this.blockParameters;
				]]></body>
			</method>

			<method name="getToolbarType">
				<body><![CDATA[
					return 'wblocktoolbar';
				]]></body>
			</method>

			<method name="getPersistentDocumentModelName">
				<body><![CDATA[
					if (this.getBlockType() == undefined)
					{
						return null;
					}
					var moduleParam = this.getBlockType().match(/modules_(\w+)_(\w+)/i);
					if (moduleParam == undefined)
					{
						wCore.debug("block type " + this.getBlockType()  + " does not match any persistent model");
						return null;
					}
					return 'modules_' + moduleParam[1] + '/' + moduleParam[2];
				]]></body>
			</method>

			<method name="isAttachedToPersistentDocument">
				<xbl:body><![CDATA[
					return this.hasAttribute("__cmpref");
				]]></xbl:body>
			</method>

			<method name="getPersistentDocumentId">
				<xbl:body><![CDATA[
					return this.getAttribute("__cmpref");
				]]></xbl:body>
			</method>

			<!-- @private -->
			<xbl:method name="cleanXmlContent">
				<xbl:parameter name="string" />
				<xbl:body><![CDATA[
					var tmpString = string.replace(/onclick="[^"]+"/gi, '');
                  	tmpString = tmpString.replace(/onfocus="[^"]+"/gi, '');
                    tmpString = tmpString.replace(/<a\s/gi, '<a disabled="true" onclick="event.preventDefault();" onfocus="event.preventDefault();" ');
					return tmpString.replace(/\s*xmlns(:[^=]+)*="[^"]*"/gi, "") + " ";;
				]]></xbl:body>
			</xbl:method>

			<method name="getXMLContent">
				<body><![CDATA[
					var node = document.createElementNS("http://www.rbs.fr/change/1.0/schema", "change:block");
					
					var display = this.getDisplay();
					for (var key in display)
					{
						if (display[key])
						{
							node.setAttribute('__' + key, display[key]);
						}
					}
					
					if (this.getWidthAsInt() > 0)
					{
						node.setAttribute("width", this.getWidth());
					}
					
					if (this.getContentWidthAsInt() > 0)
					{
						node.setAttribute("contentWidth",this.getContentWidth());
					}
					
					node.setAttribute("type", this.getBlockType());
					if (this.hasClassOverride())
					{
						node.setAttribute("class", this.getClassOverride());
					}
					
					if (this.hasAttribute("blockwidth"))
					{
					
						node.setAttribute("blockwidth", this.getAttribute("blockwidth"));
						node.setAttribute("absoluteFrontofficeWidth", this.getAttribute("blockwidth"));
					}
					else
					{
						var relativeFrontofficeWidth = this.getRelativeFrontOfficeWidthAsInt(); 
						if (relativeFrontofficeWidth != "NaN")
						{
							node.setAttribute("relativeFrontofficeWidth", relativeFrontofficeWidth);
						}
					}
					return node;
				]]></body>
			</method>

			<method name="getRelativeFrontOfficeWidthAsInt">
				<body><![CDATA[
					return Math.floor(this.getWidthAsInt()/this.parentNode.boxObject.width*100.0);
				]]></body>
			</method>

			<method name="getRelativeFrontOfficeWidth">
				<body><![CDATA[
					return this.getRelativeFrontOfficeWidthAsInt()+'%';
				]]></body>
			</method>
			
			<method name="hasClassOverride">
				<body><![CDATA[
					var display = this.getDisplay();
					return display['class'] != undefined;
				]]></body>
			</method>
			
			<method name="getClassOverride">
				<body><![CDATA[
					var display = this.getDisplay();
					if (display['class'] != undefined)
					{
						return display['class'];
					}
					return null;
				]]></body>
			</method>
			
			<!-- COMPAT METHODS -->
			<method name="getDisplay">
				<body><![CDATA[
				var result = {};
				var attributes = this.attributes;
				for (var i = 0; i < attributes.length; i++)
				{
					var key = attributes[i].nodeName;
					if (key.substring(0,2) === '__')
					{
						result[key.substring(2)] = attributes[i].nodeValue;
					}
				}
      			return result;
                ]]></body>
			</method>

			<method name="setBlockAttribute">
				<parameter name="attribute" />
				<parameter name="parameter" />
				<parameter name="value" />
				<body><![CDATA[
	                if (parameter && attribute == 'display')
	                {
						if (this.backupDisplayData == null)
	                	{
	               			this.backupDisplayData = this.getDisplay();
	                	}	
	                	attribute = '__' + parameter;
	                }
	                
                    if (!value)
                    {
                        this.removeAttribute(attribute);
                    }
                    else
                    {
                        this.setAttribute(attribute, value)
                    }

	                if (attribute == "blockwidth")
	                {
						// Resize all blocks
						this.getParentLayoutElement().resizeBlocks(); 
	                }
	              	this.layoutEditor.setIsModified(true);
                ]]></body>
			</method>

			<method name="refreshContent">
				<body><![CDATA[
				]]></body>
			</method>

			<method name="prepareMove">
				<body><![CDATA[
            	]]></body>
			</method>

			<method name="getBackupDisplayData">
				<body><![CDATA[
            		return this.backupDisplayData;
                ]]></body>
			</method>

			<method name="hasModifications">
				<body><![CDATA[
                	return this.backupDisplayData != null;
                ]]></body>
			</method>

		</implementation>
		<xbl:content xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul">
			<cdropzone anonid="leftDropZone" type="left" />
			<box anonid="container" context="blockbasepopup">
				<xbl:children />
				<tooltip anonid="propertyGridTooltip" orient="vertical" noautohide="false">
					<menuitem class="menuitem-iconic" label="&amp;modules.uixul.bo.layout.BlockPropertyGridTooltip;" image="{HttpHost}/icons/small/information.png"
						anonid="showPropertyGridMenuItem" oncommand="showPropertyGrid();" />
				</tooltip>
			</box>
			<cdropzone anonid="rightDropZone" type="right" />
		</xbl:content>
	</binding>
	
	<binding id="cBlock" extends="layout.cLayoutEditor#cBlockBase">	
		<implementation>
			<method name="initialize">
				<body><![CDATA[
					if (!this.hasContent())
		        	{
		        		this.setDefaultContent();
		        	}
					this.setParametersFromDisplayString(this.getAttribute('displayString'));    	
		           	if (!this.isEditable())
		           	{
		         		wCore.executeOnMethodExists(this, "hideRightDropZone", function(xbl){xbl.hideRightDropZone(); xbl.hideLeftDropZone();});
		          	}
		           	this.setIsLoaded();		           	
				]]></body>
			</method>
			
			<method name="refreshContent">
				<body><![CDATA[
					this.loadContent();
				]]></body>
			</method>

			<method name="getContentWidth">
				<body><![CDATA[
					var content = this.getContent();
					if (content != undefined && content.firstChild != undefined)
					{
						return content.firstChild.style.width;
					}
					return null;
				]]></body>
			</method>
			
			<method name="resize">
				<parameter name="widthInPixels" />
				<parameter name="heightInPixels" />
				<body><![CDATA[
					if (widthInPixels <= 0)
					{
						return;
					}
					var width = (widthInPixels)+'px';
					var contentWidth = (widthInPixels-this.getOffset())+'px';
					var height = heightInPixels+'px';
					var content = this.getContent();
            		if (heightInPixels != undefined)
            		{
            			this.style.height = height;
    					this.style.maxHeight = height;
    					this.style.minHeight = height;
    					if ( content != undefined )
    					{
    						var toResize = content.firstChild;
    						if (toResize != undefined)
    						{
    							toResize.style.height = height;
    							toResize.style.maxHeight = height;
    							toResize.style.minHeight = height;
    						}
    					}
    				}
    				if (widthInPixels != undefined)
            		{
            			this.style.width = width;
    					this.style.maxWidth = width;
    					this.style.minWidth = width
    					if (content != undefined)
    					{
    						var toResize = content.firstChild;
    						if (toResize != undefined)
    						{
    							toResize.style.maxWidth = contentWidth;
    							toResize.style.minWidth = contentWidth;
    							toResize.style.width = contentWidth;
    						}
    					}
    				}			
            	]]></body>
			</method>
			
			
			<field name="mDisplayBlockRequest">null</field>
			
			<method name="loadContent">
				<body><![CDATA[
					if (this.mDisplayBlockRequest) 
					{
						wCore.debug('loadContent : CANCEL previous request');
						this.mDisplayBlockRequest.abort();
						this.mDisplayBlockRequest = null;
					}
					
					var parameters = {type: this.getBlockType()}			
               		if (this.isAttachedToPersistentDocument())
               		{
               			parameters.cmpref =this.getPersistentDocumentId();
               		}
               		parameters.display = this.getDisplay();
                	parameters.pageid = pageData.id.toString();
		            parameters.pagelang = pageData.lang.toString();
		        	parameters.lang = pageData.lang.toString();
		        	var me = this;
		        	var callBack = function(result) {me.mDisplayBlockRequest = null; me.onDisplayBlockSuccess(result);}
		        	this.mDisplayBlockRequest = wCore.executeJSON(this.editor.getServerRequestModule(), 'DisplayBlock', parameters, callBack, true);
				]]></body>
			</method>
			
			<method name="onDisplayBlockSuccess">
				<parameter name="result" />
				<body><![CDATA[
					var message = '';					
					if (result.status == 'OK')
					{
						message = result.contents.message;
					}
					else
					{
						message = '<!' + '[CDATA[' + result.contents.errorMessage + ']'+ ']>';
					}
					
					if (this.assignedWidthInPixels > 0)
					{
						var width = (this.assignedWidthInPixels)+'px';
						var style =  'max-width:' + width + '; min-width:' +  width + '; width: ' + width + ';';
						var htmlData = '<div xmlns="' + HTML_XMLNS + '" anonid="contentBlock"><div style="'+ style +'">'  + this.cleanXmlContent(message) + '</div></div>';
               		}
               		else
               		{
						var style =  'min-height:10px;';
						var htmlData = '<div xmlns="' + HTML_XMLNS + '" anonid="contentBlock"><div style="'+ style +'">'  + this.cleanXmlContent(message) + '</div></div>';
               		}
               		
               		var domParser = new DOMParser();
               		var element = this.ownerDocument.importNode(domParser.parseFromString(htmlData, "text/xml").documentElement, true);
		          	this.setContent(element);
		          	if (this.assignedWidthInPixels > 0)
					{
		           		this.resize(this.assignedWidthInPixels, null);
		           	}
		        	this.getParentLayoutElement().resizeBlocks();
                ]]></body>
			</method>
			
			<method name="getOffset">
				<body><![CDATA[
					return this.getRightDropZone().collapsed ? 7 : 15;
				]]></body>
			</method>
			
			<method name="postInsert">
				<parameter name="parameters"/>
				<body><![CDATA[
					this.assignedWidthInPixels = parameters['width'];
					this.maxAllowedWidth = parameters['width'];
					if (parameters['type'] == 'left')
					{
						this.hideRightDropZone();	
						this.assignedWidthInPixels -= this.getOffset();
					}
					else
					{
						this.assignedWidthInPixels -= this.getOffset();
					}
					if (this.hasAttribute("blockwidth"))
					{
						this.assignedWidthInPixels = parseInt(this.getAttribute("blockwidth"));
					}
					this.focus();
					this.loadContent();
				]]></body>
			</method>
		</implementation>
	</binding>
	
    <binding id="cEmptyBlock" extends="layout.cLayoutEditor#cBlockBase">
		<implementation>
			<method name="initialize">
				<body><![CDATA[
					this.setBlockType(this.getAttribute('type'));
					if (this.hasAttribute("absoluteFrontofficeHeight"))
					{
						this.setContentHeight(this.getAttribute("absoluteFrontofficeHeight")+'px');
					}
					this.setParametersFromDisplayString(this.getAttribute('displayString'));
					this.getParentLayoutElement().resizeBlocks();
    			]]></body>
			</method>
			
			<method name="resize">
				<parameter name="widthInPixels" />
				<parameter name="heightInPixels" />
				<body><![CDATA[
					var width = (widthInPixels)+'px';
					var height = heightInPixels+'px';
					var contentWidth = (widthInPixels-this.getOffset())+'px';
            		var container = this;
            		if (heightInPixels != undefined)
            		{
            			this.style.height = height;
    					this.style.maxHeight = height;
    					this.style.minHeight = height;
    					
    				}
    				if (widthInPixels != undefined)
            		{
            			this.style.width = width;
    					this.style.maxWidth = width;
    					this.style.minWidth = width;
    					var toResize = this.getElementById("container");
    					{
    						toResize.style.width = contentWidth
    						toResize.style.maxWidth = contentWidth;
    						toResize.style.minWidth = contentWidth;
    					}
    				}			
            	]]></body>
			</method>
			
			<method name="setContentHeight">
				<parameter name="valueInPx"/>
				<body><![CDATA[
					this.style.height = valueInPx;
					this.setAttribute("height", this.style.height);
				]]></body>
			</method>
			
			<method name="getContentHeight">
				<body><![CDATA[
					if (this.style.height != undefined)
					{
						return this.style.height;
					}
					return null;
				]]></body>
			</method>
			
			<method name="getContentHeightAsInt">
				<body><![CDATA[
					var widthString = this.getContentHeight();
					if (widthString != undefined)
					{
						return parseInt(widthString.substring(0, widthString.lastIndexOf("px")));
					}
					return null;
				]]></body>
			</method>
			
			<method name="getOffset">
				<body><![CDATA[
					return this.getRightDropZone().collapsed ? 7 : 15;
				]]></body>
			</method>
			
			<method name="getContentWidth">
				<body><![CDATA[
					if (this.style.width != undefined)
					{
						return this.style.width;
					}
					return null;
				]]></body>
			</method>
			
			<method name="getXMLContent">
				<body><![CDATA[
					var node = document.createElementNS("http://www.rbs.fr/change/1.0/schema", "change:spacer");					
					if (this.getContentHeight() != undefined)
					{
						node.setAttribute("__height", this.getContentHeight());
						node.setAttribute("height", this.getContentHeight());
						node.setAttribute("absoluteFrontofficeHeight", this.getContentHeightAsInt());
					}
					if (this.getContentWidth() != undefined)
					{
						node.setAttribute("width", this.getContentWidth());
						node.setAttribute("contentWidth",this.getContentWidth());
					}
					
					if (this.hasAttribute("blockwidth"))
					{
						node.setAttribute("blockwidth", this.getAttribute("blockwidth"));
						node.setAttribute("absoluteFrontofficeWidth", this.getAttribute("blockwidth"));
						node.setAttribute("width", this.getAttribute("blockwidth")+'px');
					}
					else
					{
						node.setAttribute("relativeFrontofficeWidth", Math.floor(this.getWidthAsInt()/this.parentNode.boxObject.width*100.0));
					}
					return node;
				]]></body>
			</method>
			
			<method name="postInsert">
				<parameter name="parameters"/>
				<body><![CDATA[
					if (parameters['type'] == 'left')
					{
						this.hideRightDropZone();	
					}
					else
					{
					}
					if (this.hasAttribute("blockwidth"))
					{
						this.assignedWidthInPixels = parseInt(this.getAttribute("blockwidth"));
					}
					this.getParentLayoutElement().resizeBlocks();
				]]></body>
			</method>
			
			<method name="setDefaultContent">
				<body><![CDATA[
				]]></body>
			</method>
		</implementation>
    	
    	<content xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul">
			<cdropzone anonid="leftDropZone" type="left" />
			<box anonid="container"></box>
			<cdropzone anonid="rightDropZone" type="right" />
		</content>
	</binding>
	
    <binding id="cRichTextBlock" extends="layout.cLayoutEditor#cBlockBase">		
		<implementation>	
			<field name="mToolBar">null</field>
					  		
			<method name="initialize">
				<body><![CDATA[	
					this.setAttribute("id", this.editor.getTemporaryId());														
					wCore.debug("cRichTextBlock.initialize : (" + this.getAttribute("id") + ")");
					
					var initialContent = '';
					
					this.setBlockType(this.getAttribute('type'));
					this.setParametersFromDisplayString(this.getAttribute('displayString'));
					
					//Enable dragdrop zone 
					var container = this.getElementById("container");
					container.style.padding = "5px";
							
					if (this.firstChild != undefined)
					{
						if (this.firstChild.tagName == "richtextcontent")
						{						
							if (this.firstChild.firstChild != undefined)
							{
								initialContent = this.firstChild.firstChild.nodeValue;
							}
							this.removeChild(this.firstChild);
						}
					}
					else if (this.hasAttribute("content"))
					{
						initialContent = this.getAttribute("content");
						this.removeAttribute("content");
					}
					
					var element = null;
					
					if (this.firstChild != undefined)
					{
						element = this.firstChild;
						element.setAttribute("id", this.getAttribute("id") + "_editor");	
					}
					else
					{							
						element = document.createElement("crichtext");
						element.setAttribute("id", this.getAttribute("id") + "_editor");
						if (typeof(getCurrentPageData) == 'function')
						{
							var pageData = getCurrentPageData();
							element.setAttribute("blankUrlParams", "cmpref=" + pageData['id'] + "&lang=" + pageData['lang'])
						}
						element.setAttribute("style", "overflow: hidden !important; min-height: 15px; width:100px;");

						this.appendChild(element);
						element.setXHTML(initialContent);	
					}
					wCore.debug("cRichTextBlock.initialized");
    			]]></body>
			</method>
			
			<method name="setContent">
				<parameter name="element" />
				<body><![CDATA[
					return;
    			]]></body>
			</method>
			
			<method name="resize">
				<parameter name="widthInPixels" />
				<parameter name="heightInPixels" />
				<body><![CDATA[
					if (widthInPixels <= this.getOffset())
					{
						return;
					}
					
					var contentWidth = null;
					var toResize = this.firstChild;	
									
    				if (widthInPixels != undefined)
            		{
            			var width = widthInPixels + "px";
						var contentWidthInPixels = widthInPixels - this.getOffset() - 10;
            			this.style.width = width;
    					this.style.maxWidth = width;
    					this.style.minWidth = width;
    					if (toResize)
    					{
    						var contentWidth = contentWidthInPixels + "px";
    						//wCore.debug("cRichTextBlock.resize[width:" + width + ", contentWidth:" + contentWidth + "]");
    						toResize.style.maxWidth = contentWidth;
    						toResize.style.minWidth = contentWidth;
    						toResize.style.width = contentWidth;
    					}
    				}
    				
    				if (toResize && "resizeTo" in toResize)
    				{
    					toResize.resizeTo(contentWidth);
    				}
            	]]></body>
			</method>
			
			<method name="getOffset">
				<body><![CDATA[
					return this.getRightDropZone().collapsed ? 7 : 15;
				]]></body>
			</method>
			
			<method name="postInsert">
				<parameter name="parameters"/>
				<body><![CDATA[
					wCore.debug("postInsert");
					try
					{
						this.assignedWidthInPixels = parameters['width'];
						if (parameters['type'] == 'left')
						{
							this.hideRightDropZone();	
							this.assignedWidthInPixels -= this.getOffset();
						}
						else
						{
							this.assignedWidthInPixels -= this.getOffset();
						}
						this.focus();
						this.resize(this.assignedWidthInPixels);
						this.getParentLayoutElement().resizeBlocksInHbox(this.parentNode);
					}
					catch (e)
					{
						wCore.error("cRichTextBlock.postInsert", [parameters], e);
					}
				]]></body>
			</method>
			
			<method name="getToolbarType">
				<body><![CDATA[
					return 'crichtextblocktoolbar';
				]]></body>
			</method>
			
			<method name="getContentWidth">
				<body><![CDATA[
					var content = this.getContent();
					if (content != undefined)
					{
						return content.style.width;
					}
					return null;
				]]></body>
			</method>	
			
			<method name="getRichtextXMLContent">
				<body><![CDATA[			
					var domNode = document.createElementNS("http://www.rbs.fr/change/1.0/schema", "change:richtextcontent");
					var cdata = document.createCDATASection(this.getRichtextContent());
					domNode.appendChild(cdata);
					return domNode;	
				]]></body>
			</method>
			
			<method name="getRichtextContent">
				<body><![CDATA[			
					return this.getContent().getXHTML();	
				]]></body>
			</method>
			
			<method name="prepareMove">
            	<body><![CDATA[
            		var content = document.createElement("richtextcontent");
          			content.setAttribute("collapsed", "true");
          			var cdata = document.createCDATASection(this.getRichtextContent());
          			this.removeChild(this.firstChild);
          			content.appendChild(cdata);
          			this.appendChild(content);
            	]]></body>
            </method>      
		</implementation>
		
		<handlers>		
			<handler event="updatetoolbar" phase="capturing"><![CDATA[
				if (this.mToolBar)
				{
					if ("updateToolbar" in this.mToolBar)
					{
						this.mToolBar.updateToolbar(this.getContent());
					}
					else
					{
						wCore.warn("cRichTextBlock.updatetoolbar: INVALID TOOLBAR");
					}
				}
			]]></handler>			

			<handler event="xhtmlupdate" phase="capturing"><![CDATA[
				if (!this.isFocused())
				{
					this.setIsFocused(true);
				}
				this.firstChild.resizeTo();
				this.getLayoutEditor().setIsModified(true);
			]]></handler>

			<handler event="editorinitialized" phase="capturing"><![CDATA[
				this.setIsLoaded();
				this.getParentLayoutElement().resizeBlocks();
			]]></handler>
			
			<handler event="xhtmlinfo" phase="capturing"><![CDATA[
				var le = getLayoutEditor();		
				this.getLayoutEditor().showBlockInfo();
			]]></handler>				
		</handlers>
    </binding>
    
	<binding id="cDropZoneBase" extends="layout.cLayoutEditor#cEditorElement">
		<handlers>
			<handler event="focus"><![CDATA[
                event.stopPropagation();
            ]]></handler>

			<handler event="blur"><![CDATA[
                event.stopPropagation();
            ]]></handler>
		</handlers>
	
		<implementation>
			<method name="getParentLayoutElement">
				<body><![CDATA[
					var parent = this.parentNode;
					while (parent != undefined)
					{
						if (parent.tagName == "clayoutelement")
						{
							return parent;
						}
						parent = parent.parentNode;
					}
					wCore.error("cDropZoneBase has no <clayoutelement/> ancestor");
					return null;
               	]]></body>
			</method>

			<method name="onDragOver">
				<parameter name="element" />
				<parameter name="data" />
				<body><![CDATA[
               		this.getElementById('highlighter').style.backgroundColor = "green";
               	]]></body>
			</method>
			
			<method name="onFocus">
				<parameter name="event" />
				<body><![CDATA[
					
                ]]></body>
			</method>
			
			<method name="onDragOut">
				<parameter name="element" />
				<parameter name="data" />
				<body><![CDATA[
	              	this.onDragSessionEnded();
	           	]]></body>
			</method>

			<method name="onDragSessionEnded">
				<body><![CDATA[
					if (this.getElementById('highlighter'))
					{
           				this.getElementById('highlighter').style.backgroundColor = ""; 
           			}
           		]]></body>
			</method>

		</implementation>
		<xbl:content
			xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul">
			<box anonid="highlighter" flex="1" minwidth="5px"
				minheight="5px" style="" />
		</xbl:content>
	</binding>
	
	<binding id="cDropZone" extends="layout.cLayoutEditor#cDropZoneBase">
		<handlers>
			<handler event="focus"><![CDATA[
                event.stopPropagation();
            ]]></handler>

			<handler event="blur"><![CDATA[
                event.stopPropagation();
            ]]></handler>
		</handlers>
		
		<implementation>
			<constructor><![CDATA[
    			this.setAttribute("candrop", "layout/block document/block");
    			this.registerDragAndDrop(this);
    		]]></constructor>

			<method name="createNewLine">
				<body><![CDATA[
            	if (this.parentNode.tagName != 'clayoutelement')
          		{
          			wCore.debug("bottom dropZone not inside a clayoutelement it is inside a " + this.parentNode.tagName);
          			return;
          		}
          		this.removeAttribute('flex');
          		// create the hbox corresponding to the new line
          		var hbox = document.createElement('hbox');
          		var newDropzone = document.createElement('cdropzone');
          		newDropzone.setAttribute("type", "bottom");
          		// if the dropzone's next sibling exists, insertBeforeIt
          		if (this.nextSibling == undefined)
          		{
          			this.parentNode.appendChild(hbox);
          			this.parentNode.appendChild(newDropzone);
          			newDropzone.setAttribute("flex", "1");
          		}
          		else
          		{
          			this.parentNode.insertBefore(newDropzone, this.nextSibling);
          			this.parentNode.insertBefore(hbox, newDropzone);
          		}
				return hbox;        		
            	]]></body>
			</method>
			
			<method name="appendBlock">
				<parameter name="newBlock" />
				<parameter name="parent" />
				<body><![CDATA[
					parent.appendChild(newBlock);
          			parent.setAttribute("blockCount", "1");
					return parent;     
				]]></body>
			</method>

			<method name="insertBlockLeft">
				<parameter name="newBlock" />
				<body><![CDATA[
                	var parentBlock = this.parentNode;
                	var parentHbox = parentBlock.parentNode;
                	parentHbox.insertBefore(newBlock, parentBlock);	
                	var blockCount = parseInt(parentHbox.getAttribute("blockCount"));
          			parentHbox.setAttribute("blockCount", ++blockCount);
          			return parentHbox;
				]]></body>
			</method>

			<method name="insertBlockRight">
				<parameter name="newBlock" />
				<body><![CDATA[
                	var parentBlock = this.parentNode;
                	var parentHbox = parentBlock.parentNode;
                	if (parentBlock.nextSibling == undefined)
          			{
          				//newBlock.setAttribute("flex", "1");
          				parentHbox.appendChild(newBlock);	
          				parentBlock.flex = undefined;
          			}
          			else
          			{
          				parentHbox.insertBefore(newBlock, parentBlock.nextSibling);
          			}
          			var blockCount = parseInt(parentHbox.getAttribute("blockCount"));
          			parentHbox.setAttribute("blockCount", ++blockCount);
          			this.removeAttribute("flex");
          			this.hide();
          			return parentHbox;
				]]></body>
			</method>

			<method name="insertBlock">
				<parameter name="block" />
				<parameter name="parentLayoutElement" />
				<body><![CDATA[
					if (this.getAttribute("type") == "bottom")
                	{
                		var maxAllowedSize = this.getMaxAllowedWidthForDroppedBlock(); //parentLayoutElement.boxObject.width-2;
                		var parentHbox = this.createNewLine();
                		parentHbox.appendChild(block);
                		var xbl = block;
                		var parameters = { width: maxAllowedSize };                		
                		wCore.executeOnPredicate(function(){return ("postInsert" in block);}, function(){xbl.postInsert(parameters)}); 
                	} 
                	else if (this.getAttribute("type") == "left")
                	{
                		var parentCBlock = this.parentNode;
                		var parentHBox = parentCBlock.parentNode;
                		var blockArray = parentHBox.childNodes;
                		var maxAllowedSize = this.getMaxAllowedWidthForDroppedBlock(); //Math.floor((parentLayoutElement.boxObject.width)/(blockArray.length+1));
                		var parameters = { width: maxAllowedSize,
                						   type: 'left' };
                		for(var i = 0 ; i < blockArray.length ; i++)
                		{
                			if (!blockArray[i].hasAttribute("blockwidth"))
                			{
                				blockArray[i].resize(maxAllowedSize);	
                			}	
                		}
                		var xbl = block;
                		this.insertBlockLeft(block);
                		wCore.executeOnPredicate(function(){return ("postInsert" in block);}, function(){xbl.postInsert(parameters)}); 
                	}
                	else 
                	{
                		var parentCBlock = this.parentNode;
                		var parentHBox = parentCBlock.parentNode;
                		var blockArray = parentHBox.childNodes;
                		var maxAllowedSize = this.getMaxAllowedWidthForDroppedBlock(); //Math.floor((parentLayoutElement.boxObject.width)/(blockArray.length+1));
                		var parameters = { width: maxAllowedSize,
                						   type: 'right' };
                		for(var i = 0 ; i < blockArray.length ; i++)
                		{
                			if (!blockArray[i].hasAttribute("blockwidth"))
                			{
                				blockArray[i].resize(maxAllowedSize);	
                			}		
                		}
                		var xbl = block;
                		this.insertBlockRight(block);
                		wCore.executeOnPredicate(function(){return ("postInsert" in block);}, function(){xbl.postInsert(parameters)}); 
                	}
				]]></body>

			</method>

			<method name="createNewBlock">
				<parameter name="blockData"/>
				<body><![CDATA[		
					var blockType = blockData['type'];
					var newBlock = undefined;
					if (blockType == "richtext")
					{
					 	newBlock = document.createElement('crichtextblock');
					}
					else if (blockType == "empty")
					{
						newBlock = document.createElement('cemptyblock');
					}
					else
					{
						newBlock = document.createElement('cblock');
					}
						
					for (var attrName in blockData)
					{
						if (attrName === 'ref' && blockData['ref'])
						{
							newBlock.setAttribute('__cmpref', blockData['ref']);
						}
						else if (attrName === 'type' || attrName === 'content' || attrName === 'lang')
						{
							newBlock.setAttribute(attrName, blockData[attrName]);
						}
						else if (attrName.substring(0,2) === '__')
						{
							newBlock.setAttribute(attrName, blockData[attrName]);
						}
						else
						{
							wCore.debug('cDropZone.createNewBlock Ignored :' + attrName);
						}
					}
					this.insertBlock(newBlock, this.getParentLayoutElement());  
					return newBlock;           	
				]]></body>
			</method>
			
			<method name="getMaxAllowedWidthForDroppedBlock">
				<body><![CDATA[
					var parentLayoutElement = this.getParentLayoutElement();
					var maxAllowedSize = undefined;
					if (this.getAttribute("type") == "bottom")
                	{
                		 maxAllowedSize = parentLayoutElement.getWidthAsInt()-2;
                	} 
                	else 
                	{
                		var parentCBlock = this.parentNode;
                		var parentHBox = parentCBlock.parentNode;
                		var blockArray = parentHBox.childNodes;
                		maxAllowedSize = Math.floor(parentLayoutElement.getWidthAsInt()/(blockArray.length+1));
                		var fixedSizeBlocks = $(parentHBox).children("[blockwidth]");
                		var fixedSizeBlocksCount = fixedSizeBlocks.length;
                		var fixedBlocksSize = 0;
                		fixedSizeBlocks.each(function(i){
                			fixedBlocksSize += parseInt(this.getAttribute("blockwidth"))+this.getOffset();
                		});
                		var totalBlocksCount = blockArray.length+1;
                		var computedWidth =  Math.floor((parentLayoutElement.getWidthAsInt()-fixedBlocksSize)/(totalBlocksCount-fixedSizeBlocksCount));
                		maxAllowedSize = computedWidth;
                	}
                	return maxAllowedSize;
				]]></body>
			</method>

			<method name="moveBlock">
				<parameter name="block" />
				<body><![CDATA[
					var oldParentLayoutElement = block.getParentLayoutElement();
					var parentLayoutElement = this.getParentLayoutElement();					
                	block.resize(this.getMaxAllowedWidthForDroppedBlock());	
					block.prepareMove();
					this.insertBlock(block, parentLayoutElement);
					oldParentLayoutElement.cleanContent();
					oldParentLayoutElement.deleteIfEmpty();
					parentLayoutElement.cleanContent();
					return block;
                ]]></body>
			</method>

			<method name="onDrop">
				<parameter name="element" />
				<parameter name="data" />
				<body><![CDATA[
					if (this.hasDragDataForFlavour('layout/block'))
					{
						this.handleBlockMoved(this.getDragDataByFlavour('layout/block'));
					}
					else if (this.hasDragDataForFlavour('document/block'))
					{
						this.handleBlockInserted(this.getDragDataByFlavour('document/block'));
						
					}
                ]]></body>
			</method>
			
			<method name="handleBlockMoved">
				<parameter name="block" />
				<body><![CDATA[
					if (block.getRightDropZone() == this 
						|| block.getLeftDropZone() == this
						|| (block.getBottomDropZone() == this && block.previousSibling == undefined && block.nextSibling == undefined)
						|| (block.getTopDropZone() == this && block.previousSibling == undefined && block.nextSibling == undefined))
					{
						return;
					} 
					this.moveBlock(block);
					this.layoutEditor.setIsModified("true");
				]]></body>
			</method>
			
			<method name="handleBlockInserted">
				<parameter name="draggedData" />
				<body><![CDATA[
					var block = null;
					if (draggedData.length > 0)
					{
						block = this.createNewBlock(draggedData[0]);
					}
					else
					{
						block = this.createNewBlock(draggedData);
					}
					this.layoutEditor.setIsModified("true");
				]]></body>
			</method>
		</implementation>
	</binding>
	
	<binding id="cLayoutDropZone" extends="layout.cLayoutEditor#cDropZoneBase">
		<handlers>
			<handler event="focus"><![CDATA[
                event.stopPropagation();
            ]]></handler>

			<handler event="blur"><![CDATA[
                event.stopPropagation();
            ]]></handler>
		</handlers>
		
		<implementation>
			<constructor><![CDATA[
    			this.setAttribute("candrop", "layout/layout layout/block document/block");
    			this.registerDragAndDrop(this);
    		]]></constructor>

			<method name="onDrop">
				<parameter name="element" />
				<parameter name="data" />
				<body><![CDATA[
					var layoutEditor = this.getLayoutEditor();
                	if (this.getAttribute("type") == "bottom")
                	{
                		if (this.hasDragDataForFlavour('layout/layout'))
                		{
                			var draggedData = this.getDragDataByFlavour('layout/layout');
                			if (element.tagName == "clayout")
                			{
                				
                				var newDropzone = document.createElement('clayoutdropzone');
          						newDropzone.setAttribute("type", "bottom");
          						// if the dropzone's next sibling exists, insertBeforeIt
          						if (newDropzone.nextSibling == undefined)
          						{
          							newDropzone.setAttribute("flex", "1");
          						}
          						$("crichtextblock", draggedData).each(function(i){
          							this.prepareMove();
          						});
          						$(this).after(draggedData);
                				$(draggedData).after(newDropzone);
                				layoutEditor.cleanDropzones(this.parentNode, 'clayoutdropzone');
                				$("crichtextblock", draggedData).each(function(i){
          							this.initialize();
          						});
          						layoutEditor.setIsModified("true");
                			}
                			else
                			{
                				var element = this.createNewLayout(this.getDragDataByFlavour('layout/layout').columns);                			
                				wCore.executeOnMethodExists(element, "onFocus", function(xbl){xbl.postDrop(); xbl.focus();});
                				layoutEditor.setIsModified("true");
                			}
                		}
                		else if (this.hasDragDataForFlavour('document/block') || this.hasDragDataForFlavour('layout/block'))
                		{
                			var draggedData = null;
                			var isNewInsertion = true;
                			if (this.hasDragDataForFlavour('document/block'))
                			{
                				draggedData = this.getDragDataByFlavour('document/block');
                			}
                			else
                			{
                				draggedData = this.getDragDataByFlavour('layout/block');
                				isNewInsertion = false;
                			}                			
                			var element = this.createNewLayout(1);                			
                			wCore.executeOnMethodExists(element, "onFocus", function(xbl){xbl.insertDraggedData(draggedData, isNewInsertion); xbl.focus();});
                			layoutEditor.setIsModified("true");
                		}
                	} 
                ]]></body>
			</method>

			<method name="createNewLayout">
				<parameter name="columnCount"/>
				<body><![CDATA[
          			this.removeAttribute('flex');
          			// create the hbox corresponding to the new line
             	  	var layout = document.createElement("clayout");
              	 	layout.setAttribute("columnCount", columnCount);
              		var width = (this.boxObject.width)+'px';
              	 	layout.style.width = width;
              	 	layout.style.minWidth = width;
              	 	layout.style.maxWidth = width;
               	//	layout.setAttribute("flex", "1");
          			layout.removeAttribute("flex");
          			var newDropzone = document.createElement('clayoutdropzone');
          			newDropzone.setAttribute("type", "bottom");
          			// if the dropzone's next sibling exists, insertBeforeIt
          			if (this.nextSibling == undefined)
          			{
						this.parentNode.appendChild(layout);
          				this.parentNode.appendChild(newDropzone);
          				newDropzone.setAttribute("flex", "1");
          			}
          			else
          			{
          				this.parentNode.insertBefore(newDropzone, this.nextSibling);
          				this.parentNode.insertBefore(layout, newDropzone);
          			}
          			return layout;
            	]]></body>
			</method>
			
			<method name="onDragOver">
				<parameter name="element" />
				<parameter name="data" />
				<body><![CDATA[
               		this.setAttribute("class", "focused");
               	]]></body>
			</method>

			<method name="onDragOut">
				<parameter name="element" />
				<parameter name="data" />
				<body><![CDATA[
	              	this.removeAttribute("class");
	           	]]></body>
			</method>
		</implementation>
	</binding>
	
	<binding id="cLayout" extends="layout.cLayoutEditor#cEditorElement">
		<implementation>
			<field name="_columnCount">0</field>
					
			<constructor><![CDATA[
				this.setAttribute("candrag", "true");
				if ($("clayoutelement", this).length > 0)
				{
					this.style.width=this.boxObject.width;
					this.style.minWidth=this.boxObject.width;
					this.style.maxWidth=this.boxObject.width;
				}
    	        this.registerDragAndDrop(this);
    	        this.initialize();
    		]]></constructor>
    		
    		<method name="revealContent">
    			<body><![CDATA[
    			$("clayoutelement", this).each(function(i)
    	        {
    	        	this.removeAttribute("collapsed");
    	        });
    	       	]]></body>
    		</method>
    		
    		<method name="initialize">
    			<body><![CDATA[
    				this._columnCount = parseInt(this.getAttribute("columnCount"));
    				this.setIsLoaded();
    				this.initializeSize();
    				var childNodes = this.childNodes;
    				if (childNodes.length == 1)
    				{
    					return;
    				}
    				for (var i = 0; i < childNodes.length ; i++)
    				{
    					var layoutEl = childNodes[i]
    					if (i%2 == 1)
    					{
    						layoutEl.setAttribute("class", "odd col_"+i);
    					}
    					else
    					{
    						layoutEl.setAttribute("class", "even col_"+i);
    					}
    				}
    				]]></body>
    		</method>
    		
    		<method name="postDrop">
				<body><![CDATA[
					this._columnCount = parseInt(this.getAttribute("columnCount"));
					this.setNumberOfColumns(this._columnCount);
					this.initializeSize();
    			]]></body>
			</method>
			
			<method name="insertDraggedData">
				<parameter name="draggedData"/>
				<parameter name="insertion"/>
				<body><![CDATA[
					this.postDrop();
					var data = draggedData;
					var newInsertion = insertion;
					wCore.executeOnMethodExists(this.getLayoutElement(0), "insertBlockFromDraggedData", function(xbl){xbl.insertBlockFromDraggedData(data, newInsertion);});
    			]]></body>
			</method>
			
    		
			<method name="delete">
				<body><![CDATA[
					var layoutEditor = this.layoutEditor;
					var oldParent = this.parentNode;
           			this.parentNode.removeChild(this);
           			layoutEditor.cleanDropzones(oldParent, "clayoutdropzone");
           			layoutEditor.onEditorElementDeleted();           			
           		]]></body>
			</method>

			<method name="onFocus">
				<parameter name="event" />
				<body><![CDATA[
					this.layoutEditor.focusedElement = this;
	            ]]></body>
			</method>

			<method name="onBlur">
				<parameter name="event" />
				<body><![CDATA[
                ]]></body>
			</method>

			<method name="setNumberOfColumns">
				<parameter name="count" />
				<xbl:body><![CDATA[
    				var columnContainer = this; //this.getElementById("columnContainer");
    				var childNodes = columnContainer.childNodes;
    				for (var i = 0; i < childNodes.length ; i++)
    				{
    					columnContainer.removeChild(childNodes[i]);
    				}
    				for (var i = 0; i < count ; i++)
    				{
    					var layoutEl = document.createElement("clayoutelement");
    					layoutEl.setAttribute("anonid", "col"+i);
    					var width = Math.floor(this.parentNode.boxObject.width/count);
    					layoutEl.setAttribute("width", Math.floor(width)+"px");
    					layoutEl.setAttribute("widthPercentage", 100.0/(1.0*count));
    					if (count > 1)
    					{
    						if (i%2 == 1)
    						{
    							layoutEl.setAttribute("class", "odd col_"+i);
    						}
    						else
    						{
    							layoutEl.setAttribute("class", "even col_"+i);
    						}
    					}
    					columnContainer.appendChild(layoutEl);
    				}
    			]]></xbl:body>
			</method>
			
			<method name="getLayoutElement">
				<parameter name="index"/>
				<body><![CDATA[
					return $("clayoutelement", this).get(index);
				]]></body>
			</method>
			
			<method name="initializeSize">
				<body><![CDATA[
					var columnCount = $("clayoutelement", this).length;
					var totalWidth = this.parentNode.boxObject.width-8;
					var remainingWidth = 100;
					for(var i = 0; i < columnCount ; i++)
					{
						var columnToResize = $("clayoutelement", this).get(i);
						var widthInPercent = columnToResize.getAttribute("widthPercentage"); 
						if (i == columnCount - 1)
						{
							widthInPercent = remainingWidth;
						}
						else
						{
							remainingWidth -= widthInPercent;
						}						
						var widthInPixels = Math.floor((widthInPercent/100.0)*totalWidth);
						columnToResize.setAttribute("width", widthInPixels+'px');
						columnToResize.setAttribute("widthPercentage", widthInPercent);
						wCore.executeOnMethodExists(columnToResize, "resizeBlocksToWidth", function(xbl){columnToResize.resize(widthInPixels+'px'); xbl.resizeBlocksToWidth(widthInPixels); xbl.removeAttribute("collapsed");});						
					}
				]]></body>
			</method>
			
			<method name="resizeColumn">
				<parameter name="index" />
				<parameter name="percent" />
				<body><![CDATA[
					if (this._columnCount != 2)
					{
						return;
					}
					var totalWidth = this.parentNode.boxObject.width-8;
					var resizedColumnWidth = percent * totalWidth;
					var remainingWidth = totalWidth - resizedColumnWidth; 
					var resizedColumn = this.getLayoutElement(index);
					resizedColumn.resizeBlocksToWidth(resizedColumnWidth); 
					resizedColumn.setAttribute("width", Math.floor(resizedColumnWidth) + 'px');
					resizedColumn.resize(Math.floor(resizedColumnWidth) + 'px');
					resizedColumn.setAttribute("widthPercentage", Math.round(100.0*percent));
					for (var i = index+1 ; i < this._columnCount-1 ; i++)
					{
						// Code should be written here to support cLayout's with more than two cLayoutElements ...
					}
					var lastColumn = this.getLayoutElement((index+1)%this._columnCount);
					lastColumn.resizeBlocksToWidth(Math.floor(remainingWidth)); 
					lastColumn.setAttribute("width", Math.floor(remainingWidth));
					lastColumn.resize(Math.floor(remainingWidth) + 'px');
					lastColumn.setAttribute("widthPercentage", Math.floor(100.0*remainingWidth/(1.0*totalWidth)));
				]]></body>
			</method>
			
			<method name="getToolbarType">
				<body><![CDATA[
					return 'clayouttoolbar';
				]]></body>
			</method>
			
			<method name="getXMLContent">
				<body><![CDATA[
					var xml = document.createElementNS("http://www.rbs.fr/change/1.0/schema", "change:layout");
					var columns = $("clayoutelement", this).get(); 
					for(var i = 0 ; i < columns.length ; i++)
					{
						xml.appendChild(columns[i].getXMLContent());
					}
					return xml;
				]]></body>
			</method>
			
			<method name="initDragData">
				<body><![CDATA[
                	var dragData = [
                    {
                    	flavour: "layout/layout",
                        data: this
                    }
                    ];
                    return dragData;
                ]]></body>
			</method>
			
			<method name="refreshContent">
				<body><![CDATA[
					this.initializeSize();
				]]></body>
			</method>
		</implementation>
		<xbl:content
			xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul">
			<vbox anonid="container" style="">
				<hbox anonid="columnContainer">
					<xbl:children />
				</hbox>
			</vbox>
		</xbl:content>
	</binding>
	
    <binding id="cLayoutElement" extends="layout.cLayoutEditor#cEditorElement">
    	<implementation>
    		<field name="counter">1</field>
    		
    		<constructor><![CDATA[
    			this.setAttribute("candrag", "true");
    			this.setAttribute("candrop", "layout/block document/block");
    			this.registerDragAndDrop(this);
    			this.initialize();
    			this.setIsLoaded();
    			// TODO: understand why blocks are not perfectly sized on a fresh load;
    			if ($("cblock,cemptyblock,crichtextblock", this).length > 0 )
    			{
    				var block = null;
    				if ($("crichtextblock", this).length > 0)
    				{
    					block = $("crichtextblock", this).get(0);
    				}
    				block = $("cblock,cemptyblock,crichtextblock", this).get(0);
    				wCore.executeOnMethodExists(block, "resize", function(xbl){xbl.getParentLayoutElement().resizeBlocks();});
    			}
    		]]></constructor>
    		  
    		<method name="initialize">
    			<body><![CDATA[
    				if (this.firstChild != undefined)
    				{
    					return;
    				}
    				var dropZone = document.createElement("cdropzone");
    				dropZone.setAttribute("flex", "1");
    				dropZone.setAttribute("type", "bottom");
    				this.appendChild(dropZone);
    				if (this.hasAttribute("width"))
    				{
    					this.resize(this.getAttribute("width"));
    				}
    			]]></body>
    		</method>  
    		
    		<method name="insertBlockFromDraggedData">
    			<parameter name="draggedData"/>
    			<parameter name="insertion"/>
    			<body><![CDATA[
    				var xbl = this;
    				var data = draggedData;
    				var isNewInsertion = insertion;
    				wCore.executeOnPredicate(
    					function(){
    						if (xbl.firstChild == undefined)
    						{
    							return false;
    						}
    						return "handleBlockInserted" in xbl.firstChild;
    					},
    					function()
    					{
    						if (isNewInsertion)
    						{
    							xbl.firstChild.handleBlockInserted(data);
    						}
    						else
    						{
    							xbl.firstChild.handleBlockMoved(data);
    						}
    					}
    				);
    			]]></body>
    		</method>
    		
    		<method name="resize">
    			<parameter name="width"/>
    			<body><![CDATA[
    				this.setAttribute("width", width);
    				this.style.width = width;
    				this.style.maxWidth = width;
    				this.style.minWidth = width;
    				var container = this.getElementById("container")
    				if (container != undefined)
    				{
    					container.width = width;
    					container.maxWidth = width;
    					container.minWidth = width;	
    				}
    			]]></body>
    		</method>
    		
    		<method name="getWidth">
				<body><![CDATA[
					if (this.hasAttribute("width"))
					{
						return this.getAttribute("width");
					}
					return this.boxObject.width+'px';
				]]></body>
			</method>
			
			<method name="getWidthAsInt">
				<body><![CDATA[
					var widthString = this.getWidth();
					if (widthString != undefined)
					{
						return parseInt(widthString.substring(0, widthString.lastIndexOf("px")));
					}
					return widthString;
				]]></body>
			</method>
    		
			<method name="getBlockCountForLine">
				<parameter name="hboxElement" />
				<body><![CDATA[
					var cBlockArray = hboxElement.childNodes;
					return cBlockArray.length;
				]]></body>
			</method>
          	
          	<method name="resizeBlocksToWidth">
          		<parameter name="width"/>
          		<body><![CDATA[
          			var container = this;
          			var xbl = this;
          			$(this).children("hbox").each(function(i){
          				xbl.optimalResizeToWidth(this, width);
          			//	xbl.resizeBlocksInHboxToWidth(this, Math.floor(width/$(this).children("cblock").length));
          			});
          		]]></body>
          	</method>
          	
          	<method name="getMaxAllowedSizeForBlockInHbox">
          		<parameter name="hboxElement"/>
          		<body><![CDATA[
          			var blockArray = hboxElement.childNodes;
					return Math.round((this.getWidth()-2)/(blockArray.length));
          		]]></body>
          	</method>
          	
          	<method name="resizeBlocksInHbox">
          		<parameter name="hboxElement"/>
          		<body><![CDATA[
                	var maxAllowedSize = this.getMaxAllowedSizeForBlockInHbox(hboxElement);
                	this.optimalResize(hboxElement);
                	//this.resizeBlocksInHboxToWidth(hboxElement, maxAllowedSize);
                ]]></body>
          	</method>
          	
          	<method name="resizeBlocks">
          		<body><![CDATA[
          			var xbl = this;
          			$(this).children("hbox").each(function(i){
          			 	xbl.resizeBlocksInHbox(this);
          			});
                ]]></body>
          	</method>
          	
          	<method name="resizeBlocksInHboxToWidth">
          		<parameter name="hboxElement"/>
          		<parameter name="width"/>
          		<body><![CDATA[
          			var blockArray = hboxElement.childNodes;
                	for(var i = 0 ; i < blockArray.length ; i++)
                	{
                		blockArray[i].resize(width);		
                	}
                ]]></body>
          	</method>
          	
          	<method name="optimalResize">
          		<parameter name="hboxElement"/>
          		<body><![CDATA[
					this.optimalResizeToWidth(hboxElement, this.getWidthAsInt());
                ]]></body>
          	</method>
          	
          	<method name="optimalResizeToWidth">
          		<parameter name="hboxElement"/>
          		<parameter name="width"/>
          		<body><![CDATA[
          			var allBlocks =  $(hboxElement).children();
          			var fixedBlocks = $(hboxElement).children("[blockwidth]");
          			var fixedSpace = 0;
          			fixedBlocks.each(function(i){
          				fixedSpace += parseInt(this.getAttribute("blockwidth"));
          				if ("getOffset" in  this)
          				{
          					fixedSpace += this.getOffset();
          				} 
          			});
          			var flexSpace = width-fixedSpace;
          			var flexSpacePerBlock = (fixedBlocks.length == allBlocks.length) ? 0 : Math.floor(flexSpace/(allBlocks.length-fixedBlocks.length));
          			allBlocks.each(function(i){
          				if (this.hasAttribute("blockwidth"))
          				{
          					if ("resize" in this)
          					{
          						this.resize(parseInt(this.getAttribute("blockwidth"))+this.getOffset());
          					}
          					else
          					{
          						wCore.executeOnMethodExists(this, "resize", function(xbl){xbl.resize(parseInt(xbl.getAttribute("blockwidth"))+xbl.getOffset());});
          					}
          				} 
          				else
          				{
          					if ("resize" in this)
          					{
          						this.resize(flexSpacePerBlock);
          					}
          					else
          					{
          						wCore.executeOnMethodExists(this, "resize", function(xbl){xbl.resize(flexSpacePerBlock);});
          					}
          				}
          			});
                ]]></body>
          	</method>
          	
          	<method name="deleteIfEmpty">
          		<body><![CDATA[
					if ($("cblock,cemptyblock,crichtextblock", this).length == 0)
					{
						if (parseInt(this.parentNode.getAttribute("columnCount")) == 1)
						{
							this.parentNode.delete();
						}
					}
                ]]></body>
          	</method>
      
          	
            <method name="getXMLContent">
				<body><![CDATA[
					var xmlData = document.createElementNS("http://www.rbs.fr/change/1.0/schema", "change:col");
					xmlData.setAttribute("widthPercentage", this.getAttribute("widthPercentage"));
					xmlData.setAttribute("width", this.getWidth());
					$(this).children("hbox").each(function(index){
						var row = document.createElementNS("http://www.rbs.fr/change/1.0/schema", "change:row");
						var blockArray = this.childNodes;
						for (var i = 0 ; i < blockArray.length ; i++)
						{
						    var blockElement = blockArray[i].getXMLContent(); 
							if (blockArray[i].getBlockType() == "richtext")
							{	
								blockElement.appendChild(blockArray[i].getRichtextXMLContent()); 
							}
							row.appendChild(blockElement);
						}
						xmlData.appendChild(row);
					});
					return xmlData;
				]]></body>
			</method>
			
			<method name="cleanContent">
				<body><![CDATA[
					var xbl = this;
					$("hbox", this).each(function(i){
						if (this.childNodes.length == 0)
						{
							$(this).remove();	
						}
						else
						{
							this.lastChild.showRightDropZone();
							if (xbl != undefined)
							{
								xbl.resizeBlocksInHbox(this);
							}
						}
					});
					this.cleanDropzones();
				]]></body>
			</method>
            
    	</implementation>
        <xbl:content xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul">
        	<vbox anonid="container" flex="1">
        		<xbl:children/>
			</vbox>
        </xbl:content>
    </binding>
    
	<binding id="cLayoutScroller" extends="layout.cLayoutEditor#cEditorElement">
		<handlers>
			<handler event="mousemove"><![CDATA[
                this.handleMouseMoved(event);
            ]]></handler>
		</handlers>
	
		<implementation>
			<field name="autoScroll">false</field>
			<field name="scrollDirection">-1</field>
			<constructor><![CDATA[
				//this.autoScrollHandler();
			]]></constructor>
			<method name="handleMouseMoved">
				<parameter name="event" />
				<body><![CDATA[
					/*if (event.clientY - this.boxObject.y> 20  )
					{
						this.autoScroll = false;
						return;
					}
					this.autoScroll = true;*/
				]]></body>
			</method>
			
			<method name="autoScrollHandler">
				<body><![CDATA[
				/*	if (this.autoScroll)
					{
						this.layoutEditor.scrollBox.scrollBy(0, this.scrollDirection*8);
					}
					var xbl = this;
					window.setTimeout(function(){xbl.autoScrollHandler();}, 50);*/
				]]></body>
			</method>
		</implementation>
		<xbl:content
			xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul">
			<xbl:children/>
		</xbl:content>
	</binding>
</bindings>