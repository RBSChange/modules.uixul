<?xml version="1.0"?>
<bindings xmlns="http://www.mozilla.org/xbl"
	xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul">
	<binding id="wBaseList" inheritstyle="true" extends="widgets.wWidget#wWidget">
		<implementation>
			<field name="_availableActions">[ ]</field>
			<field name="_availableActionGroups">[ ]</field>
			<field name="_availableColumns">[ ]</field>
			<field name="_defaultAttachmentAttribute">'selectedcomponents'</field>
			<field name="_currentParentType">null</field>
			<field name="_preventSelectionRecursion">false</field>
			<field name="_dataSource">[ ]</field>
			<field name="_parsers">[ ]</field>
			<field name="_loadingNode">null</field>
			<field name="_isLoading">false</field>
			<field name="_loadTimeOut">false</field>
			<field name="_loadingFailure">0</field>
			<field name="_currentOffset">-1</field>
			<field name="_pageTotal">-1</field>
			<field name="_navigateTimeOut">false</field>
			<field name="_filterTimeOut">false</field>
			<field name="_filter">null</field>
			<field name="_openedNodes">[ ]</field>
			<field name="_checkedNodes">[ ]</field>
			<field name="_availableLanguages">[ ]</field>
			<field name="_availableLanguagesLabel">[ ]</field>
			<field name="_availableLanguagesMenuItems">[ ]</field>
			<field name="_systemItems">[ ]</field>
			<field name="_lang">''</field>
			<field name="_select_first_node_onload">false</field>
			<field name="_edit_onload">false</field>
			<field name="focus_timeout_id">null</field>
			<field name="default_focus_timeout">50</field>
			<field name="_oldNode">0</field>
			<field name="default_load_timeout">50</field>
			<field name="request_stack">[]</field>
			<field name="_onToggleDoSelect">false</field>
			<field name="_activateTreeFilterOnce">false</field>
			<field name="_selectedDocuments">new XML("<documents />");</field>
			<field name="_selectedNodes">[]</field>
			<field name="_useTopic">false</field>
			<field name="_lastTopicPath">''</field>			
			<field name="_pathToFollow">[]</field>	
			<field name="_pathToFollowIndex">0</field>
			<field name="_relatedBinding">undefined</field>
			<field name="_onNextLoadSuccess">[]</field>
			<!-- Moved from wList Start-->

			<property name="boxObject">
				<getter><![CDATA[
					var boxObject = this.tree.boxObject;
					boxObject.QueryInterface(Components.interfaces.nsITreeBoxObject);
					return boxObject;
				]]></getter>
			</property>

			<property name="orderChildrenPanel">
				<getter><![CDATA[
					return this.getElementById('orderChildrenPanel');
				]]></getter>
			</property>

			<method name="openTagsPanel">
				<body><![CDATA[
					this.getElementById('tagsPanel').show();
				]]></body>
			</method>


			<method name="openPreviewPanel">
				<body><![CDATA[
					if (this.isList() || !this.inMultiTree())
					{
						window.setTimeout(function(_panel){ _panel.show(true); }, 100, this.getElementById('previewPanel'));
					}
				]]></body>
			</method>

			<method name="closeTagsPanel">
				<body><![CDATA[
					this.getElementById('tagsPanel').hide();
				]]></body>
			</method>

			<method name="openOrderChildrenPanel">
				<parameter name="componentTypes" />
				<parameter name="icons" />
				<body><![CDATA[
					this.orderChildrenPanel.setComponentTypes(componentTypes);
					this.orderChildrenPanel.setIcons(icons);
					this.orderChildrenPanel.handleBroadcast();
					this.orderChildrenPanel.show();
				]]></body>
			</method>

			<method name="closeOrderChildrenPanel">
				<body><![CDATA[
					this.orderChildrenPanel.hide();
				]]></body>
			</method>

			<method name="openRenamePanel">
				<body><![CDATA[
					if (!this.inMultiTree() && this.getElementById('renamePanel'))
					{
						this.getElementById('renamePanel').show();
					}
				]]></body>
			</method>


			<method name="closeRenamePanel">
				<body><![CDATA[
					this.getElementById('renamePanel').hide();
				]]></body>
			</method>

			<!-- Moved from wList End-->

			<constructor><![CDATA[
			
				//Moved from wList Start
				
				if (this.getElementById("renamePanel"))
		        {
			        this.getElementById('renamePanel').setAttribute('id', this.id+'-rename-panel');
				    this.getElementById('renamePanel').setAttribute('attachment', this.id+'/selectedcomponents');
				}

				if (this.orderChildrenPanel)
				{
    				this.orderChildrenPanel.setAttribute('id', this.id+'-orderChildren-panel');
    				this.orderChildrenPanel.setAttribute('attachment', this.id+'/selectedcomponents');
                }

				if (this.getElementById("tagsPanel"))
				{
    				this.getElementById('tagsPanel').setAttribute('id', this.id+'-tags-panel');
				    this.getElementById('tagsPanel').setAttribute('attachment', this.id+'/selectedids');
				}

				if (this.getElementById("previewPanel"))
				{
    				this.getElementById('previewPanel').setAttribute('id', this.id+'-preview-panel');
				    this.getElementById('previewPanel').setAttribute('attachment', this.id+'/selectedcomponents');
				}

				if (this.hasAttribute('show-id-column') && this.getAttribute('show-id-column') == 'true')
				{
					var column = this.getElementById('id-column');
					column.removeAttribute('hidden');
					column.setAttribute('flex', '1');
					column.setAttribute('hideheader', 'true');
				}

				if (this.hasAttribute('filterWidth'))
				{
					this.getFilterElement('filtertext').setAttribute('width', this.getAttribute('filterWidth'));
					this.getFilterElement('filtertext').firstChild.setAttribute('width', this.getAttribute('filterWidth'));
				}
			
				//Moved from wList End
				
				if (!this.isList() && !this.hasAttribute("seltype"))
				{
					this.setAttribute("seltype", "single");
				}

				if (this.isList())
				{
				    if (this.getElementById("languagetb"))
				    {
				        this.getElementById("languagetb").setAttribute("collapsed", "true");
                    }

				    if (this.inMultiTree())
				    {
				        this.getElementById("navigationbegin").setAttribute("hidden", "true");
				        this.getElementById("navigationback2").setAttribute("hidden", "true");
    				    this.getElementById("navigationnext2").setAttribute("hidden", "true");
    				    this.getElementById("navigationpagelabel").setAttribute("hidden", "true");
    				    this.getElementById("navigationpageseparator").setAttribute("hidden", "true");
    				    this.getElementById("navigationtotal").setAttribute("hidden", "true");
    				    this.getElementById("navigationspacer").setAttribute("collapsed", "true");
    				    this.getElementById("navigationend").setAttribute("hidden", "true");
    				    this.getElementById("top-toolbox").setAttribute("class", "change-toolbox");
    				    this.getElementById("pub-column").removeAttribute("hidden");
    				    this.getElementById("pub-column").setAttribute("hideheader", "true");
    				    this.getElementById("pub-column").removeAttribute("class");
    				    this.getElementById("pub-column").removeAttribute("src");
    				    this.getElementById("pub-column").removeAttribute("label");
    				    this.getElementById("pub-column").setAttribute("style", "width: 18px;");
    				    this.getElementById("main-column").removeAttribute("primary");
				    }
				    else
				    {
				     
						this.getElementById('treecols').setAttribute("class", "main");
				        this.setAttribute("hidecolumnpicker", "false");
    				    this.getElementById("pub-column").removeAttribute("hidden");
    				    // intportg - 2008/10/07 - this always hide the filters, even if disablefilter attribute is set to "false".
    				    //if (this.getElementById("filtertb"))
				        //{
    				    //    this.getElementById("filtertb").setAttribute("collapsed", "true");
    				    //}

    				    if (this.getElementById("top-toolbox"))
				        {
    				        this.getElementById("top-toolbox").setAttribute("class", "change-toolbar-empty");
    				    }
						
						if (navigator.userAgent.indexOf('Macintosh') == -1)     
						{
							this.getElementById("tree").setAttribute("style", "margin-top: -3px !important;");
						}
				    }
				}
				else
				{
					if (!this.hasAttribute("seltype"))
    				{
    					this.setAttribute("seltype", "single");
    				}

				    if (this.inMultiTree())
				    {
				        if (this.getElementById("languagetb-spacer"))
				        {
    				        this.getElementById("languagetb-spacer").removeAttribute("collapsed");
    				    }

                        if (this.getElementById("filtertb"))
				        {
    				        this.getElementById("filtertb").setAttribute("collapsed", "true");
    				    }

                        if (this.getElementById("top-toolbox"))
				        {
    				        this.getElementById("top-toolbox").setAttribute("class", "change-toolbox");
    				    }
				    }
					else if (navigator.userAgent.indexOf('Macintosh') != -1)     
					{
						this.getElementById("top-toolbox").setAttribute("style", "margin-bottom: 6px !important;");
					}
				}

				this.initConfig();
				this.buildColumns();
				
				
				if (!this.handleBroadcast())
				{
					this._load();
				}
			]]></constructor>


			<property name="hideHeader">
				<getter><![CDATA[
					if (this.hasAttribute('hideheader') && this.getAttribute('hideheader') == 'true')
					{
						return true;
					}
					return false;
				]]></getter>
			</property>


			<property name="tree">
				<getter><![CDATA[
					return this.getElementById('tree');
				]]></getter>
			</property>


			<property name="alwaysUseDropPopup">
				<getter><![CDATA[
					return this.getAttribute('drop-popup') == 'true';
				]]></getter>
			</property>

			<method name="getWorkingLanguage">
				<body><![CDATA[
					return this._lang;
				]]></body>
			</method>


			<method name="setWorkingLanguage">
				<parameter name="lang" />
				<body><![CDATA[
					this._lang = lang;

					var menuList = this.getElementById('supportedlanguages');

					if (menuList)
					{
    					menuList.value = lang;

    					for (var i = 0; i < this._availableLanguagesMenuItems.length; i++)
    				    {
    				        if (this._availableLanguagesMenuItems[i].value == lang)
    				        {
    				            menuList.selectedItem = this._availableLanguagesMenuItems[i];
    				            break;
    				        }
    				    }
    				}
				]]></body>
			</method>


			<method name="setDataSourceParameter">
				<parameter name="name" />
				<parameter name="value" />
				<body><![CDATA[
					this._dataSource[name] = value;
				]]></body>
			</method>

			<method name="getAttachedMainList">
				<body><![CDATA[
					if (this.inMultiTree()) 
					{
						return document.getElementById(this.id + "List");
					}
					else
					{
						return this.getModule().getMainList();
					}
				]]></body>
			</method>

			<method name="locateDocument">
				<parameter name="id" />
				<body><![CDATA[
					//wCore.debug('[wBaseList.locateDocument] '+id+' in '+this.id);
					this.abortLoading();

					if (this.isList())
					{
						var tree = this.getAttachedComponent();
						var list = this;
					}
					else
					{
						var tree = this;
						var list = this.getAttachedMainList();
					}

					// The main list may not be initialized yet...
					if (!list.addFunctionOnNextLoadSuccess)
					{
						//wCore.debug('[wBaseList.locateDocument] list not initialized yet');
						var _this = this;
						wCore.executeOnMethodExists(list, 'locateDocument', function () { _this.locateDocument(id); });
					}
					// The main list may be loading...
					else if (list._isLoading)
					{
						//wCore.debug('[wBaseList.locateDocument] list not loaded yet');
						var _this = this;
						list.addFunctionOnNextLoadSuccess(function () { _this.locateDocument(id); });
					}
					else
					{
						if (this._checkAvailabilityInCurrentTreeState(tree, list, id))
						{
							return;
						}
						
						this.loadPathToId(id);
						this._load();
					}
				]]></body>
			</method>


			<method name="_load">
				<parameter name="node" />
				<parameter name="open" />
				<parameter name="silent" />
				<parameter name="offset" />
				<body><![CDATA[
				    //wCore.debug('[wBaseList._load] id = '+this.id);
				    if (this.getModule().hasAttribute('onload-locate-document') && !this.isList())
				    {
				        var id = this.getModule().getAttribute('onload-locate-document');
						this.getModule().removeAttribute('onload-locate-document');
				    	this.locateDocument(id);
				    	return;
				    }

				    if (this._isLoading == true)
				    {
				        return;
				    }

					if (!this._activateTreeFilterOnce)
					{
						this._activateTreeFilterOnce = true;
					    if (this.isList() && !this.inMultiTree())
					    {
					        if (this._checkedNodes.length > 0)
					        {
					            this.getElementById("check-column").setAttribute("src", "{IconsBase}/small/checkbox.png");
					        }
					        else
					        {
	    				        this.getElementById("check-column").setAttribute("src", "{IconsBase}/small/checkbox_empty.png");
	    				    }
							if (this.getElementById("filtertb") && this.previousSibling && this.previousSibling._isToolBar)
	    				    {
	    				        this.previousSibling.getElementById("observesContainer").appendChild(this.getElementById("filtertb"));
	    				    }
	    				}
	    			}

				    this._isLoading = true;

				    var controller = this.getModule().getController();
                    var request = controller.createRequest('get');
                    request.label = '&amp;modules.uixul.bo.baseList.Loading;';

					for (var i in this._dataSource)
					{
					    switch (i)
					    {
					       case 'rnd':
					       case 'module':
					       case 'action':
					       case 'components':
					       case '{K::WEBEDIT_MODULE_ACCESSOR}':
					       case '{K::COMPONENT_ID_ACCESSOR}':
					       case '{K::TREE_OFFSET}':
					       case '{K::LINKED_COMPONENT_ACCESSOR}':
					       case '{K::PARSER_ACCESSOR}':
					       case '{K::TREE_ORDER}':
					       case '{K::TREE_FILTER}':
					       case '{K::TREE_TYPE}':
					       case '{K::TREE_ID}':
					       case '{K::COMPONENT_ACCESSOR}':
					           break;

					       default:
					           request.addParameter(i, this._dataSource[i]);
					           break;
					    }
					}

                    if (!('module' in this._dataSource))
					{
					    request.addParameter('{K::WEBEDIT_MODULE_ACCESSOR}', this.getModule().name);
					}
					else
					{
						request.addParameter('{K::WEBEDIT_MODULE_ACCESSOR}', this._dataSource['module']);
					}

            		request.addParameter('module', 'uixul');
            		request.addParameter('action', 'GetXmlTree');

            		if (node)
            		{
            		    this._loadingNode = node;

            		    request.addParameter('{K::COMPONENT_ID_ACCESSOR}', node.itemData.id);

            		    if (this.isList())
            		    {
            		    	var newNode = node.itemData.id;
            		    }

            		    if (!silent)
            		    {
            		        var newChildren = document.createElement('treechildren');
                    		var newItem = document.createElement('treeitem');
                    		var idCell = document.createElement('treecell');
                    		var mainCell = document.createElement('treecell');
                    		var newRow = document.createElement('treerow');

                    		newItem.appendChild(newRow);
                    		newItem.appendChild(newChildren);
                    		newRow.appendChild(idCell);
                    		newRow.appendChild(mainCell);
                    		mainCell.setAttribute('label', '&amp;modules.uixul.bindings.baseList.Loading;...');
                		    mainCell.setAttribute('properties', 'item_loading');
                		    newItem.setAttribute('container' , false);

                    		var treeItems = node.getElementsByTagName('treechildren')[0];
                		    treeItems.appendChild(newItem);
                		}

            		    if (open)
            		    {
            		        node.setAttribute('open' , true);
            		    }

            		    node.itemData.cutInDepth = false;
            		}
            		else
            		{
			
						if (('root' in this._dataSource) && (this._loadingFailure == 0))
						{
						    request.addParameter('{K::COMPONENT_ID_ACCESSOR}', this._dataSource['root']);
						    if (this.isList())
						    {
						        var newNode = this._dataSource['root'];
						    }
						}

            		    this._loadingNode = null;

            		    if (!this.isList())
					    {
                            this._currentOffset = -1;
            		    }
            		}

            		if (this.isList() && newNode)
           		    {
           		    	if (this._oldNode != newNode)
           		    	{
           		    		offset = -1;
           		    		this._currentOffset = -1;
           		    	}
           		    	this._oldNode = newNode;
           		    }

            		// Get the path to locate.
					var pathToFollow = [];
					if (this.isList())
					{
						//wCore.debug('[wBaseList._load] isList');
						pathToFollow = this._pathToFollow;
						if (pathToFollow.length == 0)
						{
							var tree = this.getAttachedComponent();
							if (tree)
							{
								pathToFollow = tree._pathToFollow;
								if (typeof(pathToFollow) != 'object')
								{
									pathToFollow = [];
								}								
							}							
						}
					}
					
					if (pathToFollow.length > 0)
					{
						request.addParameter('pathToFollow', pathToFollow.join('/'));
					}
            		else if (offset >= 0)
        		    {
        		        request.addParameter('{K::TREE_OFFSET}', offset);
        		    }
        		    else if (this._currentOffset >= 0)
        		    {
        		        request.addParameter('{K::TREE_OFFSET}', this._currentOffset);
					}

        		    if ('components' in this._dataSource)
					{
						if ((this._dataSource['components'] != 'all') && (this._dataSource['components'] != '*'))
						{
							var components = this._dataSource['components'].split(/[\s,]+/);
							for (var i in components)
							{
								if (components[i].indexOf('/') == -1)
								{
									if (components[i] == 'folder')
									{
										components.push('modules_generic/folder');
									}
									components[i] = 'modules_' + this.getModule().name + '/' + components[i];
								}
							}
							request.addParameter('{K::LINKED_COMPONENT_ACCESSOR}', components);
						}
					}
					else if (!this.isList())
					{
						this._dataSource['{K::LINKED_COMPONENT_ACCESSOR}'] = [ 'modules_generic/folder' ];
					}

					if ('{K::PARSER_ACCESSOR}' in this._dataSource)
					{
					    request.addParameter('{K::PARSER_ACCESSOR}', this._dataSource['{K::PARSER_ACCESSOR}']);
					}

        		    if (this.isList() && !('{K::PARSER_ACCESSOR}' in this._dataSource))
					{
						request.addParameter('{K::PARSER_ACCESSOR}', 'XmlList');
					}

					if (this._dataSource['{K::TREE_ORDER}'])
					{
						request.addParameter('{K::TREE_ORDER}', this._dataSource['{K::TREE_ORDER}']);
					}

					if (this._filter)
					{
					    request.addParameter('{K::TREE_FILTER}', this._filter);
					}
					else if (this._dataSource['{K::TREE_FILTER}'])
					{
					    request.addParameter('{K::TREE_FILTER}', this._dataSource['{K::TREE_FILTER}']);
					}

					if (this._lang == '')
					{
						this._lang = Context.W_LANG;
					}
					
					request.addParameter('{K::LANG_ACCESSOR}', this._lang);
					

					if (this.isList())
					{
					   if (this.inMultiTree())
					   {
					       request.addParameter('{K::TREE_TYPE}', 'wmultilist');
					   }
					   else
					   {
					       request.addParameter('{K::TREE_TYPE}', 'wlist');
					   }
					}
					else
					{
					   if (this.inMultiTree())
					   {
					       request.addParameter('{K::TREE_TYPE}', 'wmultitree');
					   }
					   else
					   {
					       request.addParameter('{K::TREE_TYPE}', 'wtree');
					   }
					}

					request.addParameter('{K::TREE_ID}', this.id);
					
					var cols = this._availableColumns[this._currentParentType];
					var viewcols = '';
					for (var i = 0; i < cols.length; i++)
					{
						if (viewcols.length != 0) 
						{
							viewcols += ',';
						}
						viewcols += cols[i].ref;
					}
					if (viewcols.length != 0)
					{
						request.addParameter('viewcols', viewcols);
					}

					request.addParameter('rnd', Math.random());

            		request.setHandler(function() { controller.executeHandler(request); });

            		request.senderObject = this;
					
            		try
            		{
            			var requestIndex = controller.enqueue(request);
            			request.callBackParameters = requestIndex;
            			this.request_stack.push({index: requestIndex, request: request});
            		}
            		catch (e)
            		{
            			wCore.error("wBaseList._load", [node, open, silent, offset], e);
            		}
				]]></body>
			</method>

			<method name="abortLoading">
				<body><![CDATA[
					if (this._isLoading)
					{
						this._isLoading = false;
						for (var i = 0; i < this.request_stack.length; i++)
						{
							this.request_stack[i].request.abort();
							if (this.getModule().getController()._currentRequest && (this.getModule().getController()._currentRequest == this.request_stack[i].request))
							{
								this.getModule().getController()._currentRequest = null;
							}
							this.getModule().getController()._actionStack.splice(this.request_stack[i].index, 1);
							this.getModule().getController().release();
						}
						this.request_stack = [];
					}
				]]></body>
			</method>

			<method name="confirmLoading">
				<parameter name="index" />
				<body><![CDATA[
					var newRequestStack = [];

					for (var i = 0; i < this.request_stack.length; i++)
					{
						if (this.request_stack[i].index != index)
						{
							newRequestStack.push(this.request_stack[i]);
						}
					}
					this.request_stack = newRequestStack;
				]]></body>
			</method>
			
			<method name="onGetXmlTreeSuccess">
				<parameter name="xmlData" />
				<parameter name="httpRequest" />
				<parameter name="callBackParameters" />
				<body><![CDATA[
					this.confirmLoading(callBackParameters);
				    this._loadingFailure = 0;

				    this._systemItems = [];

				    if (!this.isList())
				    {
       		           this._currentOffset = -1;
       		        }

       		        if (xmlData.lang && (xmlData.lang != ''))
       		        {
       		           this.setWorkingLanguage(xmlData.lang);
       		        }
       		        
					if (xmlData.usetopic && (xmlData.usetopic == 'true'))
					{
						this._useTopic = true;
					}
					else
					{
						this._useTopic = false;
					}
		
					this._lastTopicPath = '';
			
					var overwrite = (xmlData.overwrite == 'true');

					if (xmlData.orderby && xmlData.orderdir)
					{
					    var treecols  = this.getElementById('treecols');
					    for (var i = 0; i < treecols.childNodes.length; i++)
    					{
    					    var treecol = treecols.childNodes[i];

    					    if (treecol.hasAttribute('ref') && (treecol.getAttribute('ref').toLowerCase() == xmlData.orderby.toString().toLowerCase()))
    					    {
        					   treecol.setAttribute('sortActive', 'true');
        					   switch (xmlData.orderdir.toString())
    					       {
    					           case 'asc':
    					               treecol.setAttribute('sortDirection', 'ascending');
    					               break;

    					           case 'desc':
    					               treecol.setAttribute('sortDirection', 'descending');
    					               break;

    					           default:
    					               treecol.setAttribute('sortDirection', 'natural');
    					               break;
    					       }
    					    }
    					    else
    					    {
    					       treecol.removeAttribute('sortActive');
    					       treecol.setAttribute('sortDirection', 'natural');
    					    }
    					}
					}

				    if (this._loadingNode && !overwrite)
                    {
                        var hasChild = false;
                        var children = this._loadingNode.getElementsByTagName('treechildren')[0];
                        for (var i = children.childNodes.length - 1; i >= 0; i--)
                        {
                            children.removeChild(children.childNodes[i]);
                        }

                        if (xmlData.d[0])
                        {
                            for each (var child in xmlData.d[0].d)
                    		{
                    		    hasChild = true;
                    		    this.processXmlData(child, this._loadingNode, false, true);
                    		}

                            if (hasChild)
                    		{
                    		    this._loadingNode.setAttribute('container' , true);
                    		    this._loadingNode.setAttribute('open' , true);
                    		}
                    		else
                    		{
                    		    this._loadingNode.setAttribute('container' , false);
                    		    this._loadingNode.setAttribute('open' , false);
                    		}

                    		this._loadingNode = null;
                        }
                    }
                    else
                    {
                        var children = this.tree.getElementsByTagName('treechildren')[0];
                        for (var i = children.childNodes.length - 1; i >= 0; i--)
                        {
                            children.removeChild(children.childNodes[i]);
                        }

                        if (xmlData.d[0])
                        {
                            if (this.isList())
                            {
                                xmlData.d[0].@t = 'go_to_parent_folder';

                                if ((xmlData.d[0].@p > 0) || (xmlData.d[0].@p != ''))
                                {
                                    xmlData.d[0].@i = xmlData.d[0].@p;
                                }
                                else
                                {
                                    xmlData.d[0].@i = 0;
                                }

                                xmlData.d[0].@p = 0;
								this.tree.itemData = null;
								
                                var newItem = this.processXmlData(xmlData.d[0], this.tree, true, false);
                               	this.tree.itemData = newItem.itemData;

                                for each (var child in xmlData.d[0].d)
                        		{
                        		    this.processXmlData(child, this.tree, false, true);
                        		}

                        		this.updateNavigationToolbar(xmlData.d[0]);
                            }
                            else
                            {
                                this.processXmlData(xmlData.d[0], this.tree, true, true);
                            }
                        }
                    }

                    if (!this.isList())
	                {
                        this.renderSystemItems(this.tree);
                    }

                    this.abortLoading();

                    if (this.isList())
	                {
						this.setAttribute('actions-select', '');
						this.setAttribute('actions-contextmenu', '');
					}

					if (this._pathToFollow.length > 0)
					{
						this._selectByPath();
					}
					else
					{
						if (this._select_first_node_onload)
						{
							this._select_first_node_onload = false;
					
							if (this.isList())
							{
								this.selectByRow(1);
							}
							else
							{
								this.selectByRow(0);
							}
						}
					
						if (this._edit_onload)
						{
							this._edit_onload = false;
					
							var editComponentValue = this.getSelectedComponents().toString();
							if (editComponentValue == this.getAttribute('editcomponent'))
							{
								this.removeAttribute('editcomponent');
							}
							this.handleDoubleClick();
						}
					}
					
					// Execute the _onNextLoadSuccess elements.
					if (this._onNextLoadSuccess.length > 0)
					{
						var functionsToExecute = this._onNextLoadSuccess;
						this._onNextLoadSuccess = [];
						for each (var functionToExecute in functionsToExecute)
						{
							functionToExecute();
						}
					}
										
                    this.onAfterLoadSuccess(xmlData, httpRequest, callBackParameters);
                ]]></body>
			</method>

			<method name="onAfterLoadSuccess">
				<parameter name="xmlData" />
				<parameter name="httpRequest" />
				<parameter name="callBackParameters" />
				<body><![CDATA[
                ]]></body>
			</method>

			<method name="addFunctionOnNextLoadSuccess">
				<parameter name="functionToExecute" />
				<body><![CDATA[
					this._onNextLoadSuccess.push(functionToExecute);
                ]]></body>
			</method>
			
			<method name="onGetXmlTreeError">
				<parameter name="xmlData" />
				<parameter name="httpRequest" />
				<parameter name="callBackParameters" />
				<body><![CDATA[
					this.confirmLoading(callBackParameters);
				    this._loadingFailure++;

				    this._currentOffset = -1;

				    this.abortLoading();

				    if (this._loadingFailure < 2)
				    {
    				    if (this._loadingNode && (this._loadingNode.itemData.parentid > 0))
                        {
                            if (!this.isList())
                            {
                                try
                                {
                                    var selectedIndex = this.tree.view.selection.currentIndex;
                                    this.selectByRow(selectedIndex - 1);
                                }
                                catch (e)
                                {
									wCore.error("wBaseList.onGetXmlTreeError", [xmlData, httpRequest, callBackParameters], e);
                                }
                            }
                            this._loadingNode = this._loadingNode.parentNode.parentNode;
                            this._load(this._loadingNode, false, true);
                        }
                        else
                        {
                        	this._load();
                        }
					}
					else if (this._loadingFailure < 4)
				    {
				    	this._load();
				    }
				    else
				    {
				    	this.onAfterLoadError(xmlData, httpRequest, callBackParameters);
				    }
				]]></body>
			</method>


			<method name="onAfterLoadError">
				<parameter name="xmlData" />
				<parameter name="httpRequest" />
				<parameter name="callBackParameters" />
				<body><![CDATA[

                ]]></body>
			</method>


			<method name="moveToParentNode">
				<body><![CDATA[
			        try
                    {
                        var selectedIndex = this.tree.view.selection.currentIndex;
                        var node = this.tree.view.getItemAtIndex(selectedIndex);
                        return node.parentNode.parentNode;
                    }
                    catch (e)
                    {
						wCore.error("wBaseList.moveToParentNode", [], e);
                    }	

                    return false;
                ]]></body>
			</method>


			<method name="selectNextNode">
				<parameter name="editWhenDone" />
				<body><![CDATA[
			        try
                    {
                        var selectedIndex = this.tree.view.selection.currentIndex;

                        if (selectedIndex <= (this.tree.view.rowCount - 2))
                        {
                            this.selectByRow(selectedIndex + 1);

                            if (editWhenDone)
                            {
                                var editComponentValue = this.getSelectedComponents().toString();
            					if (editComponentValue == this.getAttribute('editcomponent'))
            					{
            						this.removeAttribute('editcomponent');
            					}
            					this.handleDoubleClick();
                            }

                            return true;
                        }
                        else if(this.isList() && (this._pageTotal) && (this._currentOffset < (this._pageTotal - 1)))
                        {
                            this._select_first_node_onload = true;

                            if (editWhenDone)
                            {
                                this._edit_onload = true;
                            }

                            this.navigateNext();
                            return true;
                        }
                        else
                        {
                            this._select_first_node_onload = true;

                            if (editWhenDone)
                            {
                                this._edit_onload = true;
                            }

                            this.navigateBegin();
                            return true;
                        }
                    }
                    catch (e)
                    {
						wCore.error("wBaseList.selectNextNode", [editWhenDone], e);
                    }

                    return false;
                ]]></body>
			</method>

			<method name="extractXmlInfos">
				<parameter name="xmlNode" />
				<body><![CDATA[
				try {
				
					var itemData = {id:0, type:'', parentid:0, lang:'', revision:0, 
						langAvailable:false, vo:'', languages:[], hasChild:false, cutInDepth:false,
						hasPermissions:false, permissions:'', inheritedPermissions:false,
						publicationStatus:'', status:'', modificationdate:'',
						properties:[], columns:{}};
							
					var nodeVal = xmlNode.@i.toString();
					if (nodeVal != '') {itemData.id = nodeVal;}	
									
					nodeVal = xmlNode.@p.toString();
					if (nodeVal != '') {itemData.parentid = nodeVal;}
					
					if (xmlNode.@r.toString() == '1')
					{
						itemData.properties.push('hasPermissions');
						itemData.hasPermissions = true;
					}
					nodeVal = xmlNode.@pe.toString();
					if (nodeVal.length > 0)
					{
						if (nodeVal == 'allpermissions')
						{
							itemData.permissions = nodeVal;
						}
						else
						{
							itemData.permissions = ',' + nodeVal + ',';
						}
					}
					else
					{
						itemData.inheritedPermissions = true;
					}	
					
					nodeVal = xmlNode.@t.toString();
   				    if (nodeVal != '')
   				    {
   				    	itemData.type = nodeVal;
   				    	itemData.properties.push(nodeVal);
   				    }	
   				    
					if (nodeVal != 'go_to_parent_folder')
					{
					    if (xmlNode.@w.toString() == '1')
   						{
   							itemData.publicationStatus = 'workflow';
   						}
   						else if (xmlNode.@cr.toString() == '1')
   						{
   							itemData.publicationStatus = 'correction';
   						}
   						else if (xmlNode.@pu.toString() == '1')
   						{
   							itemData.publicationStatus = 'publicated';
   						}
   						else if (xmlNode.@pa.toString() == '1')
   						{
   							itemData.publicationStatus = 'publishable';
   						}
   				    }
								
					nodeVal = xmlNode.@l.toString();
					if (nodeVal != '') {itemData.lang = nodeVal;}

					nodeVal = xmlNode.@v.toString();
					if (nodeVal != '') {itemData.revision = nodeVal;}

					nodeVal = xmlNode.@s.toString();
					if (nodeVal != '')
					{
						itemData.status = nodeVal;
						itemData.properties.push(nodeVal);
					}

					nodeVal = xmlNode.@la.toString();
					if (nodeVal == '1') 
					{
						itemData.langAvailable = true;
					}
					else
					{
						itemData.properties.push('lang_unavailable')
					}
										
					nodeVal = xmlNode.@dl.toString();
					if (nodeVal != '')
					{
					    var documentLanguages = nodeVal.split(' ');
						for (var ilang = 0; ilang < documentLanguages.length; ilang++)
						{
						    if (ilang == 0)
						    {
						        itemData.vo = documentLanguages[ilang];
						    }
						    itemData.languages.push(documentLanguages[ilang]);
						}
					}

					nodeVal = xmlNode.@m.toString();
					if (nodeVal != '') {itemData.modificationdate = nodeVal;}
	
					nodeVal = xmlNode.@c.toString();
					if (nodeVal == '1')
					{
						itemData.hasChild = true;
						itemData.cutInDepth = true;
					} 
					
		            for each (var xmlProperty in xmlNode.p)
		            {
		            	var name = xmlProperty.@n.toString();
		            	itemData[name] = xmlProperty.toString();
		            	itemData.columns[name] = true;
		            }
		            
                    return itemData; 
                } 
                catch(e) 
                {
                	wCore.error("wBaseList.extractXmlInfos", [xmlNode], e);
                }          
                ]]></body>
			</method>
						
			<method name="processXmlData">
				<parameter name="xmlNode" />
				<parameter name="treeNode" />
				<parameter name="first" />
				<parameter name="deep" />
				<body><![CDATA[
					var newItem = document.createElement('treeitem');
					
					var newChildren = document.createElement('treechildren');
					var newRow = document.createElement('treerow');
					
					newItem.appendChild(newChildren);
					newItem.appendChild(newRow);
					
					var checkCell = document.createElement('treecell');
					var idCell = document.createElement('treecell');
					var pubCell = document.createElement('treecell');
					var mainCell = document.createElement('treecell');

					newRow.appendChild(checkCell);
					newRow.appendChild(idCell);
					newRow.appendChild(pubCell);
					newRow.appendChild(mainCell);

					var itemData = this.extractXmlInfos(xmlNode);
					newItem.itemData = itemData;
					newItem.isRoot = first;
					
					idCell.setAttribute('label', itemData.id);
					idCell.setAttribute('properties', 'id');

					var newRowProperties = new Array();

					if (itemData.hasPermissions)
					{
						newRowProperties.push('hasPermissions');
					}
					
					if (itemData.inheritedPermissions && treeNode && treeNode.itemData && treeNode.itemData.permissions)
					{
						itemData.permissions = treeNode.itemData.permissions;
					}
		
					if (itemData.publicationStatus != '')
					{
					    pubCell.setAttribute('properties', itemData.publicationStatus);
   				    }
   				    					
					var dataSourceColumnNames = this._availableColumns[this._currentParentType];
					
					// Store properties by column.
					var propertiesByColumn = [itemData.properties];
				    for (var ci=0 ; ci < dataSourceColumnNames.length ; ci++)
				    {
				    	if (ci > 0) {propertiesByColumn[ci] = [];}
						var column = dataSourceColumnNames[ci];
						if (column.properties)
						{
							for each (var propName in column.properties.split(' '))
							{
								if (typeof itemData[propName] != 'undefined')
								{
									propertiesByColumn[ci].push(itemData[propName]);
								}
							}
						}
					}

					if (dataSourceColumnNames.length > 0) 
					{
						var mainColumn = dataSourceColumnNames[0];
						if (typeof itemData[mainColumn.ref] != 'undefined')
						{
							mainCell.setAttribute('label', itemData[mainColumn.ref]);
						}
					}
					else
					{
						mainCell.setAttribute('label', itemData.label);
					}
					
					itemData._label = mainCell.getAttribute('label');
					
					if (itemData.type == 'go_to_parent_folder')
					{
						if (itemData.id <= 0)
						{
						    propertiesByColumn[0].push('disabled');
							mainCell.setAttribute('label', itemData._label + ' (&amp;modules.generic.backoffice.rootfolder;)');
						}
					}
					else if (!itemData.langAvailable)
					{
					    propertiesByColumn[0].push('lang_unavailable');
						newRowProperties.push('lang_unavailable');
					    mainCell.setAttribute('label', itemData._label + ' [' + this.getLanguageLabel(itemData.vo) + ']');
					}

					if (!this.isList() && this._useTopic && xmlNode.@tp && (xmlNode.@tp.toString() != '') && (xmlNode.@tp.toString() != this._lastTopicPath))
					{
						var separator = document.createElement('treeseparator');
						separator.setAttribute("properties", "topicseparator");
						separator.setAttribute("label", xmlNode.@tp);
						var tp_treeItems = treeNode.getElementsByTagName('treechildren')[0];
						tp_treeItems.appendChild(separator);
						this._lastTopicPath = xmlNode.@tp.toString();
					}

					if (this.isList() && xmlNode.@cc && (xmlNode.@cc.toString() != ''))
					{
						mainCell.setAttribute('label', mainCell.getAttribute('label') + ' (' + xmlNode.@cc.toString() + ')');
					}
												
					mainCell.setAttribute('properties', propertiesByColumn[0].join(' '));

					if (deep)
					{
                		for each (var child in xmlNode.d)
                		{
                			itemData.hasChild = true;
                		    this.processXmlData(child, newItem, false, deep);
                		}
                    }

					if (first)
					{
						newItem.setAttribute('open' , true);
					}

					if (this.isList() && !this.inMultiTree())
					{
					    if (in_array(newItem.itemData.id, this._checkedNodes))
   						{
   						    checkCell.setAttribute('value' , 'true');
   						}
   						else
   						{
					        checkCell.setAttribute('value', 'false');
					    }
					}

					if (itemData.hasChild)
					{
						newItem.setAttribute('container' , true);
						if (this.isList())
						{
						    if (in_array(newItem.itemData.id, this._openedNodes))
       						{
       						    newItem.setAttribute('open' , true);
       						}
       						else
       						{
						        newItem.setAttribute('open', false);
						    }
						}
					}
					else
					{
					    newItem.setAttribute('container' , false);
						newItem.setAttribute('open', false);
					}

					for (var i = 1; i < dataSourceColumnNames.length; i++)
					{
						var column = dataSourceColumnNames[i];
						var addCell = document.createElement('treecell');
						
						if (typeof itemData[column.ref] != 'undefined')
						{
							
							addCell.setAttribute('properties', propertiesByColumn[i].join(' '));
							addCell.setAttribute('label', itemData[column.ref]);				
						}

						newRow.appendChild(addCell);
					}
					newRow.setAttribute('properties', newRowProperties.join(' '));

					if (itemData.type != 'modules_generic_systemfolder')
					{
   						var treeItems = treeNode.getElementsByTagName('treechildren')[0];
					    treeItems.appendChild(newItem);
					}
					else
					{
					    this._systemItems.push(newItem);
					}

					return newItem;
                ]]></body>
			</method>


			<method name="renderSystemItems">
				<parameter name="tree" />
				<body><![CDATA[
				    if (this._systemItems.length > 0)
				    {
    				    var treeItems = tree.getElementsByTagName('treechildren')[0];

    				    for (var i = treeItems.childNodes.length - 1; i > 0; i--)
    				    {
    				        treeItems.removeChild(treeItems.childNodes[i]);
    					}

    				    var separator = document.createElement('treeseparator');
    				    separator.setAttribute("properties", "stdseparator");
    				    treeItems.appendChild(separator);

    				    for (var i = 0; i < this._systemItems.length; i++)
    				    {
    					    treeItems.appendChild(this._systemItems[i]);
    					}
    		        }
				]]></body>
			</method>


			<method name="onActionAborted">
				<parameter name="actionLabel" />
				<body><![CDATA[
					this.abortLoading();
				]]></body>
			</method>


			<method name="updateNavigationToolbar">
				<parameter name="node" />
				<body><![CDATA[
				    var total_page = parseInt(node.@o);
				    var next_page = parseInt(node.@x);
				    var page_index = parseInt(node.@e);

				    if (total_page > 0)
				    {
				        if (this._currentOffset < 0)
				        {
				            this._currentOffset = 0;
				        }

				        if (this.isList() && !this.inMultiTree())
				        {
				            this.getElementById('treecols').setAttribute("class", "main-navigation");
				        }

				        this._pageTotal = total_page;

				        this.getElementById('navigationindex').removeAllItems();

				        if (total_page > 1000)
				        {
				            var step = 100;
				        }
				        else if (total_page > 100)
				        {
				            var step = 50;
				        }
				        else if (total_page > 50)
				        {
				            var step = 10;
				        }
				        else if (total_page > 20)
				        {
				            var step = 5;
				        }
				        else
				        {
				            var step = 1;
				        }

				        if (step > 1)
				        {
				            this.getElementById('navigationindex').appendItem(1, 1);
				        }

				        for (var i = step; i < total_page; i += step)
				        {
				            this.getElementById('navigationindex').appendItem(i, i);
				        }

				        this.getElementById('navigationindex').appendItem(total_page, total_page);

				        this.getElementById("navigationtb").removeAttribute("collapsed");

				        this.getElementById('navigationtotal').value = total_page;

				        if (page_index > 0)
				        {
				            this._currentOffset = page_index;
                        }
                        else if (next_page > 0)
                        {
                            this._currentOffset = next_page - 1;
                        }

                        if (this._currentOffset == 0)
                        {
                            this.getElementById('navigationbegin').setAttribute('disabled', 'true');
                            this.getElementById('navigationback').setAttribute('disabled', 'true');
                            this.getElementById('navigationback2').setAttribute('disabled', 'true');
                            this.getElementById('navigationend').removeAttribute('disabled');
                            this.getElementById('navigationnext').removeAttribute('disabled');
                            this.getElementById('navigationnext2').removeAttribute('disabled');
                        }
                        else if (this._currentOffset == (total_page - 1))
                        {
                            this.getElementById('navigationbegin').removeAttribute('disabled');
                            this.getElementById('navigationback').removeAttribute('disabled');
                            this.getElementById('navigationback2').removeAttribute('disabled');
                            this.getElementById('navigationend').setAttribute('disabled', 'true');
                            this.getElementById('navigationnext').setAttribute('disabled', 'true');
                            this.getElementById('navigationnext2').setAttribute('disabled', 'true');
                        }
                        else
                        {
                            this.getElementById('navigationbegin').removeAttribute('disabled');
                            this.getElementById('navigationback').removeAttribute('disabled');
                            this.getElementById('navigationback2').removeAttribute('disabled');
                            this.getElementById('navigationend').removeAttribute('disabled');
                            this.getElementById('navigationnext').removeAttribute('disabled');
                            this.getElementById('navigationnext2').removeAttribute('disabled');
                        }
                        var currentOffsetValue = this._currentOffset + 1;
                        if (currentOffsetValue < 1)
                        {
                            currentOffsetValue = 1;
                        }
                        this.getElementById('navigationindex').value = currentOffsetValue;
				    }
				    else
				    {
				        if (this.isList() && !this.inMultiTree())
				        {
				            this.getElementById('treecols').setAttribute("class", "main");
				        }
				        if (this.getElementById("navigationtb"))
				        {
				            this.getElementById("navigationtb").setAttribute("collapsed", "true");
				        }
				    }
                ]]></body>
			</method>


			<method name="navigateBegin">
				<body><![CDATA[
				    this._currentOffset = 0;
				    this.refresh();
                ]]></body>
			</method>


			<method name="navigateSelect">
				<body><![CDATA[
				    clearTimeout(this._navigateTimeOut);
				    this._currentOffset = parseInt(this.getElementById('navigationindex').value) - 1;
				    this._currentOffset = Math.min(this._pageTotal - 1, this._currentOffset);
				    this._currentOffset = Math.max(0, this._currentOffset);
				    this.refresh();
				    this.appendPageToList(this._currentOffset + 1);
                ]]></body>
			</method>


			<method name="navigateInput">
				<body><![CDATA[
				    clearTimeout(this._navigateTimeOut);
			        this._navigateTimeOut = setTimeout(function(xbl){ xbl.navigateSelect(); }, 1000, this);
                ]]></body>
			</method>


			<method name="navigateBack">
				<parameter name="quick" />
				<body><![CDATA[
				    if (quick)
				    {
				        if (this._pageTotal > 1000)
    			        {
    			            var step = 50;
    			        }
    			        else if (this._pageTotal > 100)
    			        {
    			            var step = 25;
    			        }
    			        else
    			        {
    			            var step = 5;
    			        }
    			    }
    			    else
			        {
			            var step = 1;
			        }
				    this._currentOffset = Math.max(0, this._currentOffset - step);
				    this.refresh();
                ]]></body>
			</method>


			<method name="navigateNext">
				<parameter name="quick" />
				<body><![CDATA[
				    if (quick)
				    {
				        if (this._pageTotal > 1000)
    			        {
    			            var step = 50;
    			        }
    			        else if (this._pageTotal > 100)
    			        {
    			            var step = 25;
    			        }
    			        else
    			        {
    			            var step = 5;
    			        }
    			    }
    			    else
			        {
			            var step = 1;
			        }
				    this._currentOffset = Math.min(this._pageTotal - 1, this._currentOffset + step);
				    this.refresh();
                ]]></body>
			</method>


			<method name="navigateEnd">
				<body><![CDATA[
				    this._currentOffset = this._pageTotal - 1;
				    this.refresh();
                ]]></body>
			</method>


			<method name="appendPageToList">
				<parameter name="page" />
				<body><![CDATA[
				    if (page && (page != null))
				    {
    				    var found = false;
    				    var menulist = this.getElementById('navigationindex');
    				    items = menulist.firstChild.childNodes;
    				    var index = 1;
                        for (var i = 0; i < items.length; i++)
                        {
                            if (parseInt(items[i].getAttribute("value")) == page)
                            {
                                found = true;
                                break;
                            }
                            if (parseInt(items[i].getAttribute("value")) > page)
                            {
                                break;
                            }
                            index++;
                        }
                        if (!found)
                        {
                            var newItem = menulist.insertItemAt(index - 1, page, page);
                        }
                    }
                ]]></body>
			</method>


			<method name="getFilterElement">
				<parameter name="name" />
				<body><![CDATA[
				     var element = this.getElementById(name);

				     if (!element && this.previousSibling && this.previousSibling._isToolBar)
				     {
				        element = this.previousSibling.getElementById(name);
				     }

				     return element;
				]]></body>
			</method>


			<method name="filterSelect">
				<body><![CDATA[
					if (this._filterTimeOut)
					{
				    	window.clearTimeout(this._filterTimeOut);
					}

				    if (this.inMultiTree() && this._multitree && this._multitree._currentTree)
		            {
		                var oldFilter = this._multitree._currentTree._filter;
	       			    var newFilter = trim(this.getFilterElement('filtertext').value);

                        if (newFilter)
    			        {
    			            this._multitree._currentTree._filter = newFilter;
    			        }
    			        else
    			        {
    			            this._multitree._currentTree._filter = null;
    			        }

    			        if (this._multitree._currentTree._filter != oldFilter)
    			        {
    			            this._multitree._currentTree._currentOffset = -1;
     			            this._multitree._currentTree.refresh();
     			            this.appendFilterToList(this._multitree._currentTree._filter);
    			        }
		            }
		            else
		            {
    		            var oldFilter = this._filter;
	       			    var newFilter = trim(this.getFilterElement('filtertext').value);

    			        if (newFilter)
    			        {
    			            this._filter = newFilter;
    			        }
    			        else
    			        {
    			            this._filter = null;
    			        }

    			        if (this._filter != oldFilter)
    			        {
    			            this._currentOffset = -1;
     			            this.refresh();
     			            this.appendFilterToList(this._filter);
    			        }
			        }
                ]]></body>
			</method>

			<method name="appendFilterToList">
				<parameter name="filter" />
				<body><![CDATA[
				    if (filter != null)
				    {
    				    filter = trim(filter);
    				    var found = false;
    				    var menulist = this.getFilterElement('filtertext');
    				    items = menulist.firstChild.childNodes;
                        for (var i = 0; i < items.length; i++)
                        {
                            if (items[i].label == filter)
                            {
                                found = true;
                                break;
                            }
                        }
                        if (!found && filter)
                        {
                            var newItem = menulist.insertItemAt(1, filter, filter);
                        }
                    }
                ]]></body>
			</method>

			<method name="filterInput">
				<body><![CDATA[
					var xbl = this;
					if (this._filterTimeOut)
					{
				    	window.clearTimeout(this._filterTimeOut);
				    }
				    this._filterTimeOut = window.setTimeout(function(){ xbl.filterSelect(); }, 1000);
                ]]></body>
			</method>
			
			<method name="refreshForLangSwitch">
				<body><![CDATA[
					var relatedTrees = null;

                    if (!this.inMultiTree())
                    {
                        relatedTrees = this.getObservers();
                    }
		            else if (this.inMultiTree() && this._multitree && this._multitree._currentTree)
		            {
		                relatedTrees = new Array(this._multitree._currentTree);
		            }

					var node = false;
	
					var pathLoaded = false;

					for (var i = 0; i < relatedTrees.length; i++)
					{
						relatedTree = relatedTrees[i];
						// Only lists and trees has to be synchronized.
						if (typeof(relatedTree.tree) != 'undefined' && typeof(relatedTree.refresh) != 'undefined')
						{
							relatedTree._lang = this._lang;
					
					   		if (relatedTree.tree && relatedTree.tree.view && relatedTree.tree.view.selection.currentIndex >= 0)
							{
								node = relatedTree.tree.view.getItemAtIndex(relatedTree.tree.view.selection.currentIndex);
								this.loadPathToId(node.itemData.id);
								pathLoaded = true;
								relatedTree.clearSelection();
							}
							else
							{
								relatedTree.refresh();
							}
						}
					}
					
					node = false;
					
					if (this.tree.view.selection.currentIndex >= 0)
					{
						node = this.tree.view.getItemAtIndex(this.tree.view.selection.currentIndex);
					
						if (!pathLoaded)
						{
							this.loadPathToId(node.itemData.id);
						}
					
						this.clearSelection();
					}
					
					try
					{
						this.abortLoading();
						if (this._loadTimeOut)
						{
							clearTimeout(this._loadTimeOut);
						}
						this._loadTimeOut = setTimeout(function(xbl){ xbl._load(); }, this.default_load_timeout, this);
					}
					catch (e) 
					{
						wCore.error("wBaseList.refreshForLangSwitch", [], e);
					}
			 	]]></body>
			</method>
			
			<method name="loadPathToId">
				<parameter name="id" />
				<body><![CDATA[
					this._pathToFollow = this.getController().getPathToIdForModule(id, this.getModule().name);
					this._pathToFollowIndex = 0;
				]]></body>
			</method>
			
			<method name="languageSelect">
				<body><![CDATA[
					var newLang = trim(this.getElementById('supportedlanguages').value);
					var oldLang = this._lang;
					
			        if (newLang)
			        {
			            this._lang = newLang;
			        }

			        if (this._lang != oldLang)
			        {
			            this.refreshForLangSwitch();
			        }
                ]]></body>
			</method>


			<method name="changeParser">
				<parameter name="parserName" />
				<body><![CDATA[
					this._dataSource["{K::PARSER_ACCESSOR}"] = parserName;
					this._load();
				]]></body>
			</method>


			<method name="initConfig">
				<body><![CDATA[
					this.__setupActions();
					this.__setupColumns();
					this.__setupDatasource();
					this.__setupLanguages();
				]]></body>
			</method>


			<method name="buildColumns">
				<parameter name="parentType" />
				<body><![CDATA[
					if (typeof(parentType) == 'undefined')
					{
						parentType = 'default';
					}

					if (! (parentType in this._availableColumns) )
					{
						parentType = 'default';
					}

					if (! (parentType in this._availableColumns) )
					{
						throw new Error("Must define columns for " + this.tagName + " \"" + this.id + "\"");
					}

					if (this._currentParentType == parentType)
					{
						return;
					}

					this.removeColumns();
					this._currentParentType = parentType;
					var cols = this._availableColumns[parentType];

					if (cols[0].flex)
					{
					   this.getElementById('main-column').setAttribute('flex', cols[0].flex);
					}

					if (cols[0].label && this.isList() && !this.inMultiTree())
					{
					   this.getElementById('main-column').setAttribute('label', cols[0].label);
					}

					if (!cols[0].hidden)
					{
					   this.getElementById('main-column').setAttribute('ref', cols[0].ref);
					}

					for (var i = 1; i < cols.length; i++)
					{
					    var splitter = document.createElement('splitter');
    					splitter.setAttribute('class', 'tree-splitter');
    					this.getElementById('treecols').appendChild(splitter);
    					this.addColumn(cols[i]);
					}
				]]></body>
			</method>


			<method name="removeColumns" doc-access="private"
				doc-text="Removes all the user defined columns">
				<body><![CDATA[
					var treecols  = this.getElementById('treecols');
					for (var i = treecols.childNodes.length - 1; i > 3; i--)
                    {
                        treecols.removeChild(treecols.childNodes[i]);
					}
				]]></body>
			</method>


			<method name="addColumn"
				doc-text="Adds a column in the list" doc-access="private">
				<parameter name="attributes" />
				<body><![CDATA[
					var treecols = this.getElementById('treecols');
					var newCol = document.createElement('treecol');
					if (attributes.flex)
					{
					   newCol.setAttribute('flex', attributes.flex);
					}
					if (attributes.width)
					{
					   newCol.setAttribute('width', attributes.width);
					}

					if (attributes.label && this.isList() && !this.inMultiTree())
					{
					   newCol.setAttribute('label', attributes.label);
					}

					if (this.hasAttribute('hideheader') && (this.getAttribute('hideheader') == 'true'))
					{
					   newCol.setAttribute('hideheader', 'true');
					}

					if (attributes.hidden)
					{
					   newCol.setAttribute('hidden', attributes.hidden);
					   newCol.setAttribute('ignoreincolumnpicker', 'true');
					}
					else
					{
					   newCol.setAttribute('ref', attributes.ref);
					}

					if (attributes.ignoreincolumnpicker)
					{
					   newCol.setAttribute('ignoreincolumnpicker', 'true');
					}

					treecols.appendChild(newCol);
				]]></body>
			</method>


			<method name="handleSelectAll">
				<body><![CDATA[
					this.tree.view.selection.selectAll();
					if (this.isList() && this.tree.view.getCellText(0, this.tree.columns["type"]) == "go_to_parent_folder")
					{
						this.tree.view.selection.clearRange(0, 0);
					}
				]]></body>
			</method>


			<method name="handleCopy">
				<body><![CDATA[

				]]></body>
			</method>


			<method name="handleCut">
				<body><![CDATA[

				]]></body>
			</method>


			<method name="handlePaste">
				<body><![CDATA[

				]]></body>
			</method>


			<method name="handleSelect">
				<body><![CDATA[
				    if (this.hasAttribute("onSelect"))
				    {
				        try
				        {				  
				            var module = this.getModule();
				            var action = this.getAttribute("onSelect");
				            wCore.debug('handleSelect : ' + action);				            
				            module[action](this);
						}
				        catch(e)
					    {
					    	wCore.error("wBaseList.handleSelect", [], e);
						}
					} 
					else if (this.isList() && this.inMultiTree())
					{
						window.setTimeout(function(_tree){ _tree.openPreviewPanel(); }, 100, this);
					}
				]]></body>
			</method>


			<method name="onDeleteSuccess">
				<parameter name="e4x" />
				<body><![CDATA[
					this.onActionSuccess(e4x);
					var module = this.getModule();
					if (module)
					{
						module.onDeleteSuccess(e4x, this);
					}
				]]></body>
			</method>


			<method name="hidePanelsAfterDeletion">
				<parameter name="module" />
				<body><![CDATA[
					var previewPanel = this.getElementById("previewPanel");
					if (previewPanel)
					{
						var documents = new XML(previewPanel.getAttribute('selectedcomponents'));
						if ( ! previewPanel.hasAttribute('collapsed') && documents.document.length() > 0 )
						{
							var docFound = false;
							for (var i = 0; i < documents.document.length(); i++)
							{
								var doc = documents.document[i];
								var documentId   = doc.component.(@name=="id").toString();
								for (var j = 0; j < module._checkAfterDelete.length; j++)
								{
									if (module._checkAfterDelete[j] == documentId)
									{
										previewPanel.hide();
										docFound = true;
										break;
									}
								}
								if (docFound) break;
							}
						}
					}

					var tagsPanel = this.getElementById("tagsPanel");
					if (tagsPanel)
					{
						var val = tagsPanel.getAttribute(tagsPanel._defaultAttachmentAttribute);
						if (val.length > 0 && ! tagsPanel.hasAttribute('collapsed'))
						{
							var ids = tagsPanel.getAttribute(tagsPanel._defaultAttachmentAttribute).split(/\s+/);
							var docFound = false;
							for (var i=0 ; i<ids.length ; i++)
							{
								var documentId   = ids[i];
								for (var j = 0; j < module._checkAfterDelete.length; j++)
								{
									if (module._checkAfterDelete[j] == documentId)
									{
										tagsPanel.hide();
										docFound = true;
										break;
									}
								}
								if (docFound) break;
							}
						}
					}

					var orderChildrenPanel = this.getElementById("orderChildrenPanel");
					if (orderChildrenPanel)
					{
						var val = orderChildrenPanel.getAttribute('selectedcomponents');
						if (val)
						{
							var docFound = false;
							var e4xPanel = new XML(val);
							var documentId = e4xPanel.document[0].component.(@name=="id").toString();
							for (var j = 0; j < module._checkAfterDelete.length; j++)
							{
								if (module._checkAfterDelete[j] == documentId)
								{
									orderChildrenPanel.hide();
									docFound = true;
									break;
								}
							}
							if (!docFound) orderChildrenPanel.handleBroadcast();
						}
					}
				]]></body>
			</method>


			<method name="autoSelect">
				<body><![CDATA[
					if (!this.isList() && this.getAttribute("auto-select") != "false")
					{
						this.tree.view.toggleOpenState(0);
						this.tree.view.selection.select(0);
					}
				]]></body>
			</method>


			<method name="isList">
				<body><![CDATA[
					return true;
				]]></body>
			</method>

			<method name="inMultiTree">
				<body><![CDATA[
					return this.hasAttribute("in-multi-tree");
				]]></body>
			</method>
			
			<method name="isNavigationTree">
				<body><![CDATA[
					return !this.isList() && !this.inMultiTree();
				]]></body>
			</method>			
			
			<method name="openFolder">
				<body><![CDATA[
				var components = this.getSelectedComponents();
				if (!components || !components.document || (components.document.length() == 0))
				{
					return;
				}

				var doc = this.getSelectedComponents().document[0];
				var type = doc.component.(@name=="type").toString();
				var id   = doc.component.(@name=="id").toString();
				var parentid   = doc.component.(@name=="parentid").toString();
				var perm = doc.component.(@name=="permissions").toString();
				if (perm != 'allpermissions' && perm.indexOf(',edit,') == -1)
				{
					return;
				}

				if (this.isList() && (id > 0))
				{
					this._dataSource["root"] = id;
					this.abortLoading();
					if (this._loadTimeOut)
		        		{
		        			clearTimeout(this._loadTimeOut);
		        		}
		            		this._loadTimeOut = setTimeout(function(xbl){ xbl._load(); }, this.default_load_timeout, this);
					window.setTimeout(function (tree, id, parentid) { tree.selectById(id, parentid); }, 500, this.getAttachedComponent(), id, parentid);
				}
				]]></body>
			</method>


			<method name="refresh">
				<parameter name="node" />
				<parameter name="refreshAttachedComponent" />
				<body><![CDATA[
    				if (!node) 
    				{
						if (this.tree.view.selection.currentIndex >= 0) 
						{
							node = this.tree.view.getItemAtIndex(this.tree.view.selection.currentIndex);
						}
					}
					
					if (!this.isList()) 
					{
						this._load(node, false, true);
						if (node) 
						{
							window.setTimeout( 
								function(tree, id, parentid) {tree.selectById(id, parentid);},
								500,
								this,
								node.itemData.id, node.itemData.parentid
							);
						}
					} 
					else 
					{
						this._load();
						if (node) 
						{
							window.setTimeout(
								function(tree, id) {tree.selectById(id);},
								500,
								this,
								node.itemData.id
							);
						}
					}
					
					if (refreshAttachedComponent == true) 
					{
						var attachedComponent = this.getAttachedComponent();
						if (attachedComponent && 'refresh' in attachedComponent) 
						{
							wCore.debug('[wBaseList.refresh] refresh attached component.');
							attachedComponent.refresh(null, refreshAttachedComponent);
						}
					}
				]]></body>
			</method>

			<method name="getSelectedComponents"
				doc-text="Returns an E4X object that holds information about the selected documents in the widgets."
				doc-type="E4X Object (XML)">
				<body><![CDATA[
					return this._selectedDocuments;
				]]></body>
			</method>
			
			<method name="getSelectedNodes">
			<body><![CDATA[ 
				return this._selectedNodes;
				]]></body>
			</method>			


			<method name="checkEventTarget">
				<parameter name="event" />
				<body><![CDATA[
				    var checked = false;

				    var tn = event.originalTarget.tagName;

					if (tn == 'treechildren' || tn == 'tree')
					{
					    checked = true;

    					var selectedIndex = this.tree.view.selection.currentIndex;
                        if (selectedIndex >= 0)
                        {
        			        var selectedNode = this.tree.view.getItemAtIndex(selectedIndex);

        			        if (selectedNode && selectedNode.tagName
        			        && (selectedNode.tagName.toLowerCase() == "treeseparator"))
            			    {
            			        checked = false;
            			    }
            			}
                    }

                    return checked;
				]]></body>
			</method>


			<method name="getCheckedIds">
				<body><![CDATA[
					return this._checkedNodes;
				]]></body>
			</method>


			<method name="getSelectedIds">
				<body><![CDATA[
					return wCore.getSelectionAttribute(this.getSelectedComponents(), 'id');
				]]></body>
			</method>


			<method name="getSelectedLabels">
				<body><![CDATA[
					return wCore.getSelectionAttribute(this.getSelectedComponents(), 'label');
				]]></body>
			</method>


			<method name="getSelectedTypes">
				<body><![CDATA[
					return wCore.getSelectionAttribute(this.getSelectedComponents(), 'type', true);
				]]></body>
			</method>


			<method name="handleBroadcast">
				<parameter name="observes" />
				<body><![CDATA[
					var documents = new XML(this.getAttribute('selectedcomponents'));
					
					// Synchronize the lang.
					// TODO : here we supose that a list is attached to a unique element. 
					if (typeof(this.getAttachedComponent(0)) != 'undefined' && typeof(this.getAttachedComponent(0)._lang) != 'undefined')
					{
						this._lang = this.getAttachedComponent(0)._lang;
					}
					
					this.setAttribute('actions-select', '');
					this.setAttribute('actions-contextmenu', '');

					if (documents.document.length() > 0)
					{
						var parentId   = documents.document[0].component.(@name=="id").toString();
						var parentType = documents.document[0].component.(@name=="type").toString();
						this.buildColumns(parentType);
						this._dataSource["root"] = parentId;
						this._dataSource["{K::COMPONENT_ACCESSOR}"] = parentType;
						try
						{
							this.abortLoading();
							if (this._loadTimeOut)
				        	{
				        		clearTimeout(this._loadTimeOut);
				        	}
				            this._loadTimeOut = setTimeout(function(xbl){ xbl._load(); }, this.default_load_timeout, this);
						}
						catch (e)
						{
							wCore.error("wBaseList.handleBroadcast", [observes], e);
						}
						return true;
					}
					return false;
				]]></body>
			</method>


			<method name="handleDoubleClick">
				<body><![CDATA[
            				this.getModule().handleDoubleClick(this);
				]]></body>
			</method>


			<method name="checkSecurity">
				<parameter name="actionName" />
				<parameter name="document" />
				<body><![CDATA[
					var permissions = document.component.(@name=="permissions").toString();
					if (permissions == 'allpermissions' || this.getActionGroup(actionName) != null)
					{
						return true;
					}
					return permissions.indexOf(',' + actionName + ',') >= 0;
				]]></body>
			</method>


			<method name="checkDisplay">
				<parameter name="actionName" />
				<parameter name="document" />
				<parameter name="countDocument" />
				<body><![CDATA[
					var methodName = 'checkDisplay_'+actionName;
					var module = this.getModule();
					return !(methodName in module) || module[methodName](document, countDocument);
				]]></body>
			</method>

			<method name="compileAvailableActions">
				<parameter name="eventType" />
				<parameter name="documents" />
				<parameter name="countDocument" />
				<body><![CDATA[
           		try
				{
					var availableActions = null;
					for (var i=0; i< countDocument; i++)
					{
						var document = documents.document[i];

						if (!document)
						{
						    continue;
						}
						
						var type = document.component.(@name=='type').toString();	
						var toolbartype = document.component.(@name=='toolbartype').toString();

						if (toolbartype != '') 
						{
							type = toolbartype;
						}
							
						if (type == 'go_to_parent_folder')
						{
							availableActions = null;
							break;
						}
						
						if ( (type in this._availableActions) && (eventType in this._availableActions[type]) )
						{
							if (availableActions == null)
							{
								availableActions = this._availableActions[type][eventType];
							}
							else
							{
							 	var newAvailableActions = [];
							 	var newActions = this._availableActions[type][eventType];
								for (var x = 0; x < newActions.length; x++)
								{
									if (availableActions.indexOf(newActions[x]) != -1)
									{
										newAvailableActions.push(newActions[x]);
									}
								}
								availableActions = newAvailableActions;
							}
						}
					}
	
					if (availableActions == null)
					{
						availableActions = [];
					}					
					return availableActions;
				}
          		catch (e)
           		{
               		wCore.error("wBaseList.compileAvailableActions", [eventType, documents, countDocument], e);
           		}
				]]></body>
			</method>

			<method name="setAvailableActions">
				<parameter name="eventType" />
				<body><![CDATA[
           		try
           		{
					var resultActions = [];
					var addedActions = [];
					var rejectedActions = [];
					var availableActions = [];

					var documents = this.getSelectedComponents();
					var countDocument = documents.document.length();

					if (eventType == "contextmenu")
					{
						var availableActionsToMerge = [];
						availableActionsToMerge.push(this.compileAvailableActions("contextmenu", documents, countDocument));
						availableActionsToMerge.push(this.compileAvailableActions("select", documents, countDocument));

						for (var i = 0; i < availableActionsToMerge.length; i++)
						{
							for (var k = 0; k < availableActionsToMerge[i].length ; k++)
							{
								if (!in_array(availableActionsToMerge[i][k], availableActions))
								{
									availableActions.push(availableActionsToMerge[i][k]);
								}
							}
						}
					}
					else
					{
						availableActions = this.compileAvailableActions(eventType, documents, countDocument);
					}

					for (var i = 0; i < countDocument; i++)
					{
						var document = documents.document[i];
	
						if (!document)
						{
						    continue;
						}
	
						for (var k = 0; k < availableActions.length ; k++)
						{
						    var s = availableActions[k];

						    if (s.length == 1)
						    {
						        resultActions.push(s);
						    }
						    else if ( addedActions.indexOf(s) == -1 )
						    {
							if (this.checkSecurity(s, document) && this.checkDisplay(s, document, countDocument) && rejectedActions.indexOf(s) == -1)
						        {
								if (this.isLocalizedAction(s, document))
								{
								    if (this.isActionAvailableForDocument(s, document))
								    {
								        resultActions.push(s);
									addedActions.push(s);
								    }
								    else
								    {
								    	resultActions.push('!' + s);
									addedActions.push(s);
								    }
								}
								else if (this.isActionAvailableForDocument(s, document))
								{
									resultActions.push(s);
									addedActions.push(s);
								}
							}
							else if (rejectedActions.indexOf(s) == -1)
							{
								rejectedActions.push(s);
							}
						}
						else if (!this.checkSecurity(s, document) || !this.checkDisplay(s, document))
						{
							addedActions.splice(addedActions.indexOf(s), 1);
							resultActions.splice(resultActions.indexOf(s), 1);
						}
					    }
					}

					if (eventType == "contextmenu")
					{
						var groupOfActionsToOrder = [];
						var groupIndex = 0;

						for (var i = 0; i < resultActions.length; i++)
						{
							var actionItem = resultActions[i];
							
							if (!groupOfActionsToOrder[groupIndex])
							{
								groupOfActionsToOrder[groupIndex] = [];
							}

							if ((actionItem == "-") || (actionItem == "|"))
							{
								// INTCOURS - Wanted to order actions within separators (as group of actions),
								// but too much mess around the existing stuff, separators are simply ignored (for the moment).
								// Uncomment the following lines in order to activate actions' grouping :
								/*
								groupOfActionsToOrder[groupIndex].push({id: actionItem});
								groupIndex++;
								*/
							}
							else if (this.getModule()._actionInformation[actionItem])
							{
								groupOfActionsToOrder[groupIndex].push({id: actionItem, label: this.getModule()._actionInformation[actionItem].label});
							}
							else
							{
								groupOfActionsToOrder[groupIndex].push({id: actionItem, label: actionItem});												   }								
						}

						resultActions = [];

						for (var i = 0; i < groupOfActionsToOrder.length; i++)
						{						
							groupOfActionsToOrder[i].sort(this.contextMenuSorter);
							for (var k = 0; k < groupOfActionsToOrder[i].length; k++)
							{
								resultActions.push(groupOfActionsToOrder[i][k].id);
							}
						}
					}

					var actions = resultActions.join(' ');	
					//wCore.debug('actions-' + eventType + ' : ' + actions);			
					this.setAttribute('actions-' + eventType, actions);
                }
           		catch (e)
           		{
               		wCore.error("wBaseList.setAvailableActions", [eventType], e);
           		}
				]]></body>
			</method>

			<method name="contextMenuSorter">
				<parameter name="a" />
				<parameter name="b" />
				<body><![CDATA[
					if ((a.id == "-") || (a.id == "|"))
					{
						return 1;
					}
					if ((b.id == "-") || (b.id == "|"))
					{
						return -1;
					}					
					if (a.label < b.label)
					{
						return -1;
					}
					else if (a.label > b.label)
					{
						return 1;
					}
					return 0;
				]]></body>
			</method>

			<method name="isActionAvailableForDocument">
				<parameter name="actionName" />
				<parameter name="document" />
				<body><![CDATA[
				    if ((actionName == 'translateFrom') && this.getModule().isContextLangAvailable(document))
				    {
				        return false;
				    }
				    var actionObject = this.getModule().getActionInformation(actionName);
					return actionObject == null || actionObject.localized == false || this.getModule().isContextLangAvailable(document);
				]]></body>
			</method>


			<method name="isLocalizedAction">
				<parameter name="actionName" />
				<parameter name="document" />
				<body><![CDATA[
				    if ((actionName == 'translateFrom') && this.getModule().isContextLangAvailable(document))
				    {
				        return true;
				    }
					var actionObject = this.getModule().getActionInformation(actionName);
					return actionObject != null && actionObject.localized == true;
				]]></body>
			</method>


			<method name="getActionGroup">
				<parameter name="name" />
				<body><![CDATA[
					if (name in this._availableActionGroups)
					{
						return this._availableActionGroups[name];
					}
					return null;
				]]></body>
			</method>


			<method name="__setupActions">
				<body><![CDATA[
				]]></body>
			</method>


			<method name="__setupColumns">
				<body><![CDATA[
				]]></body>
			</method>


			<method name="__setupDatasource">
				<body><![CDATA[
				]]></body>
			</method>


			<method name="__setupLanguages">
				<body><![CDATA[
				var controller = this.getModule().getController();
                var request = controller.createRequest('get');
                request.addParameter('module', 'generic');
                request.addParameter('action', 'GetSupportedLanguages');
                request.addParameter('rnd', Math.random());
        		request.setHandler(function() { controller.executeHandler(request); });
        		request.senderObject = this;
        		try
        		{
        			controller.enqueue(request);
        		}
        		catch (e)
        		{
        			wCore.error("wBaseList.__setupLanguages", [], e);
        		}
				]]></body>
			</method>


			<method name="getLanguageLabel">
				<parameter name="language" />
				<body><![CDATA[
				    for (var i = 0; i < this._availableLanguages.length; i++)
				    {
				        if (this._availableLanguages[i] == language)
				        {
				            return this._availableLanguagesLabel[i];
				        }
				    }
				    return language;
				]]></body>
			</method>


			<method name="onGetSupportedLanguagesSuccess">
				<parameter name="xmlData" />
				<parameter name="httpRequest" />
				<body><![CDATA[
				    if (this.getElementById('supportedlanguages'))
				    {
    				    this._availableLanguages = [];
    				    this._availableLanguagesMenuItems = [];

    				    var languages = xmlData.message.split(' ');

    				    for (var i = 0; i < languages.length; i++)
    				    {
    				        var language = languages[i].split(':');

    				        this._availableLanguages.push(language[0]);

    				        this._availableLanguagesLabel.push(language[1]);

    				        if (!this.isList())
        				    {
                                var newItem = this.getElementById('supportedlanguages').appendItem(language[1], language[0]);
                                this._availableLanguagesMenuItems.push(newItem);
        				    }
    				    }

    				    this.getElementById('supportedlanguages').selectedIndex = 0;
    				}
                ]]></body>
			</method>


			<method name="handleTreeSort">
				<parameter name="event" />
				<parameter name="treecol" />
				<body><![CDATA[
				    if (treecol.hasAttribute('ref') && treecol.getAttribute('ref'))
				    {
				        var sort = null;

    				    switch (treecol.getAttribute('sortDirection'))
    				    {
    				        case 'ascending':
    				            sort = 'desc';
    				            break;

    				        case 'descending':
    				            sort = null;
    				            break;

    				        default:
    				            sort = 'asc';
    				            break;
    				    }

    				    if (sort != null)
    				    {
    				        this._dataSource['{K::TREE_ORDER}'] = treecol.getAttribute('ref') + '/' + sort;
    				        this.refresh();
    				    }
    				    else
    				    {
    				        this._dataSource['{K::TREE_ORDER}'] = '';
    				        this.refresh();
    				    }
    				}
				]]></body>
			</method>


			<method name="toggleOpenState">
				<parameter name="event" />
				<parameter name="checkTwisty" />
				<body><![CDATA[
					var row = {}, col = {}, obj = {};
    				this.tree.treeBoxObject.getCellAt(event.clientX, event.clientY, row, col, obj);
    				if (obj.value && (row.value >= 0))
    				{

    				    var selectedNode = this.tree.view.getItemAtIndex(row.value);

    				    if (this.isList() && !this.inMultiTree() && (col.value.type == col.value.TYPE_CHECKBOX))
    				    {
    				        if (in_array(selectedNode.itemData.id, this._checkedNodes))
    				        {
                                var newCheckedNodes = [];
                                for (var i = 0; i < this._checkedNodes.length; i++)
                                {
                                    if (this._checkedNodes[i] != selectedNode.itemData.id)
                                    {
                                        newCheckedNodes.push(this._checkedNodes[i]);
                                    }
                                }
                                this._checkedNodes = newCheckedNodes;
                            }
                            else
                            {
                                this._checkedNodes.push(selectedNode.itemData.id);
                            }

                            if (this._checkedNodes.length > 0)
        				    {
            				    this.getElementById("check-column").setAttribute("src", "{IconsBase}/small/checkbox.png");
            				}
            				else
            				{
            				    this.getElementById("check-column").setAttribute("src", "{IconsBase}/small/checkbox_empty.png");
            				}

    				        return;
    				    }

                        if (((checkTwisty == true) && (obj.value == 'twisty'))
                        || ((checkTwisty == false) && (obj.value != 'twisty')))
                        {
                            if (!this.isList())
                            {
                                this._currentOffset = -1;
                            }

                            if ((checkTwisty == true) && (obj.value == 'twisty'))
                            {
                                if (in_array(selectedNode.itemData.id, this._openedNodes))
                                {
                                    var newOpenedNodes = [];
                                    for (var i = 0; i < this._openedNodes.length; i++)
                                    {
                                        if (this._openedNodes[i] != selectedNode.itemData.id)
                                        {
                                            newOpenedNodes.push(this._openedNodes[i]);
                                        }
                                    }
                                    this._openedNodes = newOpenedNodes;
                                }
                                else
                                {
                                    this._openedNodes.push(selectedNode.itemData.id);
                                }
                            }

                            if (selectedNode.itemData.cutInDepth == true)
        			        {
					            if (this._onToggleDoSelect)
					            {
					            	this.selectByRow(row.value);
					            }
					            else
					            {
					            	if (this._loadTimeOut)
						        	{
						        		clearTimeout(this._loadTimeOut);
						        	}
						            this._loadTimeOut = setTimeout(function(xbl){ xbl._load(selectedNode, true); }, this.default_load_timeout, this);
					            }

        			            // this._load(selectedNode, true);
        			        }
                        }
					}
				]]></body>
			</method>


			<method name="canDrop">
				<parameter name="element" />
				<parameter name="data" />
				<body><![CDATA[
                    try
                    {
                        var canDrop = false;
                        var selectedIndex = this.tree.view.selection.currentIndex;
                        if (selectedIndex >= 0)
                        {
        			        var node = this.tree.view.getItemAtIndex(selectedIndex);
        			        if (this.hasAttribute("candrop")
                            && (parseBoolean(this.getAttribute("candrop")) != false))
                            {
                                canDrop = true;
                            }
        			    }
                        return canDrop;
                    }
                    catch (e)
                    {
                        wCore.error("wBaseList.canDrop", [element, data], e);
                    }
				]]></body>
			</method>

			<method name="_selectByPath">
				<parameter name="tryCount" />
				<body><![CDATA[
					//wCore.debug('[wBaseList._selectByPath] start');
					if (!this._pathToFollowIndex)
					{
						this._pathToFollowIndex = 0;
					}

					if (this.isList())
					{
						var tree = this.getAttachedComponent();
						var list = this;
					}
					else
					{
						var tree = this;
						var list = this.getAttachedMainList();
					}
					
					var intermediateNodeFound = true;
					var documentId = this._pathToFollow[this._pathToFollowIndex];
					
					if (this._pathToFollowIndex < (this._pathToFollow.length - 1))
					{
						intermediateNodeFound = false;
						for (var i = 0; i < tree.tree.view.rowCount; i++)
						{
							var treenode = tree.tree.view.getItemAtIndex(i);

		    				if (treenode.itemData && (treenode.itemData.id == documentId))
		    				{
		       					//wCore.debug('[wBaseList._selectByPath] intermediateNodeFound in tree');
		       					tree.selectByRow(i);		    			   
	               				var boxObject = tree.tree.boxObject;
								boxObject.QueryInterface(Components.interfaces.nsITreeBoxObject);
								boxObject.ensureRowIsVisible(i);
				       			intermediateNodeFound = true;			
								this._pathToFollowIndex++;
								if (this._pathToFollowIndex == (this._pathToFollow.length - 1))
								{
									//wCore.debug('[wBaseList._selectByPath] to look for the last element, wait the end of list loading');
									var _this = this;
									var documentId = this._pathToFollow[this._pathToFollowIndex];
									list.addFunctionOnNextLoadSuccess(function () { _this._trySelectByPathFinalIndex(tree, list, documentId); });
								}
		  						break;
		    				}
						}

						if (!intermediateNodeFound)
						{
							//wCore.debug('[wBaseList._selectByPath] !intermediateNodeFound in '+this.id);
							if (list._isLoading)
							{
								var _this = this;
								list.addFunctionOnNextLoadSuccess(function () { _this._selectByPath(); });
							}
							else
							{
								for (var i = 0; i < list.tree.view.rowCount; i++)
								{
									var treenode = list.tree.view.getItemAtIndex(i);
		
				    				if (treenode.itemData && (treenode.itemData.id == documentId))
				    				{
				       					//wCore.debug('[wBaseList._selectByPath] intermediateNodeFound in list');
										treenode.setAttribute('open', 'true');
										list.selectByRow(i);
			               				var boxObject = list.tree.boxObject;
										boxObject.QueryInterface(Components.interfaces.nsITreeBoxObject);
										boxObject.ensureRowIsVisible(i);
						       			intermediateNodeFound = true;
										this._pathToFollowIndex++;
										this._selectByPathFinalIndex(tree, list, this._pathToFollow[this._pathToFollowIndex]);
										break;
				    				}
								}
								
								if (!intermediateNodeFound)
								{
									//wCore.debug('[wBaseList._selectByPath] node not found');
									this._pathToFollow = [];
									this._pathToFollowIndex = 0;
									this.getModule().handleLocateDocument(false);
									return;
								}
							}
						}
					}
					else if (this._pathToFollowIndex == 0 && this._pathToFollow.length == 1)
					{
						//wCore.debug('[wBaseList._selectByPath] we look for a first level element');
						list._load();
						var _this = this;
						var documentId = this._pathToFollow[this._pathToFollowIndex];
						list.addFunctionOnNextLoadSuccess(function () { _this._trySelectByPathFinalIndex(tree, list, documentId); });
					}
				]]></body>
			</method>
			
			<method name="_trySelectByPathFinalIndex">
				<parameter name="tree" />
				<parameter name="list" />
				<parameter name="id" />
				<body><![CDATA[
					if (tree._isLoading)
					{
						//wCore.debug('[wBaseList._selectByPath] to look for the last element, wait the end of tree loading');
						var _this = this;
						tree.addFunctionOnNextLoadSuccess(function () { _this._trySelectByPathFinalIndex(tree, list, id); });
					}
					else if (list._isLoading)
					{
						//wCore.debug('[wBaseList._selectByPath] to look for the last element, wait the end of list loading');
						var _this = this;
						list.addFunctionOnNextLoadSuccess(function () { _this._trySelectByPathFinalIndex(tree, list, id); });
					}
					else
					{
						//wCore.debug('[wBaseList._selectByPath] call _selectByPathFinalIndex');
						this._selectByPathFinalIndex(tree, list, id);
					}
				]]></body>
			</method>

			<method name="_checkAvailabilityInCurrentTreeState">
				<parameter name="tree" />
				<parameter name="list" />
				<parameter name="id" />
				<body><![CDATA[
					var nodeFound = false;
					var widget = null;

					try
					{
						var i = list.tree.view.selection.currentIndex; 
						if (i >= 0)
						{
							var treenode = list.tree.view.getItemAtIndex(i);

		    				if (treenode.itemData && (treenode.itemData.id == id))
	    					{
              					var boxObject = list.tree.boxObject;
								boxObject.QueryInterface(Components.interfaces.nsITreeBoxObject);
								boxObject.ensureRowIsVisible(i);
								nodeFound = true;
								widget = list;			
							}
						}
						else
						{
							wCore.info('[wBaseList._checkAvailabilityInCurrentTreeState] list.tree.view.selection.currentIndex = '+i);
							return false;
						}

						if (!nodeFound)
						{
							for (var i = 0; i < list.tree.view.rowCount; i++)
							{
								var treenode = list.tree.view.getItemAtIndex(i);

			    				if (treenode.itemData && (treenode.itemData.id == id))
		    					{
		       						list.selectByRow(i);		    			   
	               					var boxObject = list.tree.boxObject;
									boxObject.QueryInterface(Components.interfaces.nsITreeBoxObject);
									boxObject.ensureRowIsVisible(i);
									nodeFound = true;
									widget = list;			
									break;
		    					}
							}
						}

						if (!nodeFound)
						{
							var i = tree.tree.view.selection.currentIndex; 
							if (i >= 0)
							{
								var treenode = tree.tree.view.getItemAtIndex(i);
	
			    				if (treenode.itemData && (treenode.itemData.id == id))
			    				{
		               				var boxObject = tree.tree.boxObject;
									boxObject.QueryInterface(Components.interfaces.nsITreeBoxObject);
									boxObject.ensureRowIsVisible(i);
						       		nodeFound = true;
									widget = tree;				
								}
							}
							else
							{
								wCore.info('[wBaseList._checkAvailabilityInCurrentTreeState] tree.tree.view.selection.currentIndex = '+i);
								return false;
							}
						}

						if (nodeFound)
						{
							this._pathToFollow = [];
							this._pathToFollowIndex = 0;
							this.getModule().handleLocateDocument(treenode, widget);
						}
					}
					catch (e) 
					{
						wCore.error("wBaseList._checkAvailabilityInCurrentTreeState", [], e);
					}

					return nodeFound;
				]]></body>
			</method>

			<method name="_selectByPathFinalIndex">
				<parameter name="tree" />
				<parameter name="list" />
				<parameter name="id" />
				<parameter name="tryCount" />
				<body><![CDATA[
					//wCore.debug('[wBaseList._selectByPathFinalIndex]');
					var nodeFound = false;
					var widget = null;

					for (var i = 0; i < list.tree.view.rowCount; i++)
					{
						var treenode = list.tree.view.getItemAtIndex(i);

		    				if (treenode.itemData && (treenode.itemData.id == id))
		    				{
		       					list.selectByRow(i);		    			   
	               					var boxObject = list.tree.boxObject;
							boxObject.QueryInterface(Components.interfaces.nsITreeBoxObject);
							boxObject.ensureRowIsVisible(i);
							nodeFound = true;
							widget = list;			
		  					break;
		    				}
					}

					if (!nodeFound)
					{
						for (var i = 0; i < tree.tree.view.rowCount; i++)
						{
							var treenode = tree.tree.view.getItemAtIndex(i);

		    					if (treenode.itemData && (treenode.itemData.id == id))
		    					{
		       						tree.selectByRow(i);		    			   
	               						var boxObject = tree.tree.boxObject;
								boxObject.QueryInterface(Components.interfaces.nsITreeBoxObject);
								boxObject.ensureRowIsVisible(i);
					       			nodeFound = true;
								widget = tree;				
		  						break;
		    					}
						}
					}

					this._pathToFollow = [];
					this._pathToFollowIndex = 0;
					if (!nodeFound)
					{
						//wCore.debug('[wBaseList._selectByPathFinalIndex] node not found');
						this.getModule().handleLocateDocument(false);
					}
					else
					{
						//wCore.debug('[wBaseList._selectByPathFinalIndex] node found in '+widget.id);
						this.getModule().handleLocateDocument(treenode, widget);
					}
				]]></body>
			</method>

			<method name="selectById">
				<parameter name="id" />
				<parameter name="parentid" />
				<parameter name="callback" />
				<parameter name="trycount" />
				<body><![CDATA[
					if (!trycount)
					{
						trycount = 0;
					}
					var itemFound = false;
					if (this.isList())
					{
						var parentFound = true;
					}
					else
					{
						var parentFound = false;
					}
					for (var j = 0; j < this.tree.view.rowCount; j++)
					{
					    var treenode = this.tree.view.getItemAtIndex(j);
					    if (!parentFound && treenode.itemData && (treenode.itemData.id == parentid))
					    {
						if (treenode.getAttribute('open') != 'true')
						{
							treenode.setAttribute('open', 'true');
						}
						parentFound = true;
					    }
					    else if (treenode.itemData && (treenode.itemData.id == id))
					    {
					       	this.selectByRow(j);		    			   
				               	var boxObject = this.tree.boxObject;
						boxObject.QueryInterface(Components.interfaces.nsITreeBoxObject);
						boxObject.ensureRowIsVisible(j);		 
						itemFound = true; 
			     			if (callback) callback(this, treenode);				
					  	break;
					    }
					}					
					if (!itemFound && (trycount < 8))
					{
						window.setTimeout(
							function (tree, id, parentid, callback, trycount) { 
								tree.selectById(id, parentid, callback, trycount); 
							}, 
							350, 
							this, 
							id, 
							parentid, 
							callback, 
							trycount++
						);
					}
				]]></body>
			</method>


			<method name="selectByPosition">
				<parameter name="x" />
				<parameter name="y" />
				<body><![CDATA[
                    try
                    {
                        var boxObject = this.tree.boxObject;
                        boxObject.QueryInterface(Components.interfaces.nsITreeBoxObject);
                        var row = {};
                        var col = {};
                        var obj = {};
                        boxObject.getCellAt(x, y, row, col, obj);
                        this.selectByRow(row.value);
                        var cellData =
                        {
                            row: row.value,
                            col: col.value
                        }
                        return cellData;
                    }
                    catch (e)
                    {
                        wCore.error("wBaseList.selectByPosition", [x, y], e);
                    }
				]]></body>
			</method>


			<method name="selectByRow">
				<parameter name="row" />
				<body><![CDATA[
                    if (row >= 0)
                    {
                        this.tree.view.selection.select(row);
                    }
				]]></body>
			</method>


			<method name="clearSelection">
				<body><![CDATA[
                    try
                    {
                        this.tree.view.selection.clearSelection();
                    }
                    catch (e)
                    {
                        wCore.error("wBaseList.clearSelection", [], e);
                    }
				]]></body>
			</method>

			<method name="onDragOver">
                <parameter name="element" />
                <parameter name="data" />
                <body><![CDATA[
                    try
                    {
                        if (this.getDragEvent()
                        && ((wDragAndDrop.draggedElement != this)
                        || (this.dragAndDropInProcess == false)))
                        {
                            if (this._preventSelectionRecursion == true)
                            {
                                this._preventSelectionRecursion = false;
                            }
                            else
                            {
                                this._preventSelectionRecursion = true;
                                this.selectByPosition(this.getDragEvent().clientX, this.getDragEvent().clientY);
                            }
                        }
                        this.tree.focus();   
                    }
                    catch (e)
                    {
                        wCore.error("wBaseList.onDragOver", [element, data], e);
                    }
                ]]></body>
            </method>

			<method name="checkDragComponents">
			<body><![CDATA[
					return;
                ]]></body>
			</method>			

			<method name="initDragData">
				<body><![CDATA[
                    try
                    {
                    	this.debug('initDragData');
                    	this.checkDragComponents();
                    	var components = this.getSelectedComponents();                   	
                    	if (components === undefined || components.document[0] === undefined)
                        {
                       		this.debug('initDragData : No component selected');
                        	return;
                        }
                        
                        var dragData = [];
                        dragData.push({flavour: "listitem/component", data: components});
                        
                        var selectedComponent = null; 
                        var ids = [];  	
                    	for (var i=0; i < components.document.length(); i++)
                        {
                        	var idtype = [components.document[i].component.(@name=="id").toString(),
                        		components.document[i].component.(@name=="type").toString()];
                            ids.push(idtype);
                        }
                        dragData.push({flavour: "application/json-documentidtype-array", data: wCore.stringifyJSON(ids)});    
                            
                        var selectedComponent = components.document[0].component;
                        if (selectedComponent.(@name=="block").toString())
                        {
                        	var blockParams = {
                                ref: selectedComponent.(@name=="id").toString(),
                                lang: selectedComponent.(@name=="lang").toString(),
                                type: selectedComponent.(@name=="block").toString(),
                                label: selectedComponent.(@name=="label").toString(),
                                display: selectedComponent.(@name=="display").toString()
                            }
                            
                            if (! blockParams.display)
                            {
                                blockParams.display = "class: " + blockParams.type.split('_').join('-');
                            }

							//Explode display attribute
                        	var pairs =  blockParams.display.split(';');
                        	for (var idx = 0; idx < pairs.length; idx++)
                        	{
                        		var keyValue = pairs[idx].split(':');
                        		if (keyValue.length == 2)
                        		{
                        			var name = keyValue[0].replace(/(?:^\s+|\s+$)/g, '');
                        			var valkey = keyValue[1].replace(/(?:^\s+|\s+$)/g, '');
                        			if (name != '' && valkey != '')
                        			{
                        				blockParams['__' + name] = valkey;
                        			}
                        		}
                        	}

                            
                            for (var i in components.document)
                            {
                                if (i > 0)
                                {
                                    selectedComponent = components.document[i].component;
                                    blockParams.ref += " " + selectedComponent.(@name=="id").toString();
                                }
                            }
                            var blockData = {
                                flavour: "document/block",
                                data: objectToAssocString(blockParams)
                            };
                            dragData.push(blockData);
                        }

                    	
                        var htmlContent = '';
                        for (var i in components.document)
                        {
                            selectedComponent = components.document[i].component;
                            if (selectedComponent.(@name=="htmllink").toString())
                            {
                            	htmlContent += selectedComponent.(@name=="htmllink").toString();
                            }
                        }
                        if (htmlContent)
                        {
                            var htmlData = {
                                flavour: "text/html",
                                data: htmlContent
                            };
                            dragData.push(htmlData);
                        }

                        var hasPlainLink = false;
                        for (var i in components.document)
                        {
                            selectedComponent = components.document[i].component;
                            if (selectedComponent.(@name=="plainlink").toString())
                            {
                                var plainData = {
                                    flavour: "text/unicode",
                                    data: selectedComponent.(@name=="plainlink").toString()
                                };
                                dragData.push(plainData);
                                hasPlainLink = true;
                                break;
                            }
                        }
                    	
                        if (!hasPlainLink)
                        {
                            var plainLabels = [];
                            for (var i in components.document)
                            {
                                selectedComponent = components.document[i].component;
                                if (selectedComponent.(@name=="label").toString())
                                {
                                    plainLabels.push(selectedComponent.(@name=="label").toString());
                                }
                            }
                            if (plainLabels.length > 0)
                            {
                                var plainData = {
                                    flavour: "text/unicode",
                                    data: plainLabels.join(', ')
                                };
                                dragData.push(plainData);
                            }
                        }

                        return dragData;
                    }
                    catch (e)
                    {
                        wCore.error("wBaseList.initDragData", [], e);
                    }
                ]]></body>
			</method>


			<method name="getDragRelativePosition">
				<parameter name="UIContainer" />
				<body><![CDATA[
                    try
                    {
                        if (!UIContainer)
                        {
                            UIContainer = this.tree.view.selection;
                        }
                        var eventX = this.getDragEvent().clientX
                        var eventY = this.getDragEvent().clientY;
                        var boxObject = this.tree.boxObject;
                        boxObject.QueryInterface(Components.interfaces.nsITreeBoxObject);
                        var row = {};
                        var col = {};
                        var obj = {};
                        boxObject.getCellAt(eventX, eventY, row, col, obj);
                        var x = {};
                        var y = {};
                        var width = {};
                        var height = {};
                        this.tree.boxObject.getCoordsForCellItem(row.value, col.value, obj, x, y, width, height);
                        var boxObjectData =
                        {
                            x: x.value + this.tree.boxObject.x,
                            y: y.value + this.tree.boxObject.y + 18,
                            width: this.tree.boxObject.width,
                            height: 18
                        };
                        var marginData =
                        {
                            top: 3,
                            right: 5,
                            bottom: 3,
                            left: 5
                        }
                        return wDragAndDrop.getDragRelativePosition(boxObjectData, UIContainer, marginData);
                    }
                    catch (e)
                    {
                        wCore.error("wBaseList.getDragRelativePosition", [UIContainer], e);
                    }
                ]]></body>
			</method>
			
			<method name="buildE4XSelection">
				<body><![CDATA[			
					this._selectedDocuments = new XML('<documents/>');
					this._selectedNodes = [];
					
					var ids = [];
					var langs = [];
					var start = new Object();
					var end = new Object();
					var numRanges = this.tree.view.selection.getRangeCount();
					var index = 0;
					var module = this.getModule();		
					for (var t = 0; t < numRanges; t++)
					{
						this.tree.view.selection.getRangeAt(t, start, end);
						for (var v = start.value; v <= end.value; v++)
						{
							this._selectedDocuments.document[index] = new XML('<document/>');
							var node = this.tree.view.getItemAtIndex(v);
							this._selectedNodes.push(node);
							var dataIndex = 0;							
							for (var data in node.itemData)
							{
								if (data !== "columns" && node.itemData[data])
								{
							   		this._selectedDocuments.document[index].component[dataIndex] = new XML('<component name="' + data + '"><![CDATA[' + node.itemData[data] + ']]'+'></component>');
							   		dataIndex++;
							   	}
							}
							
							this._selectedDocuments.document[index].@index = v;
							index++;
						}
					}
					
					if (this._selectedNodes.length == 1 && this.isNavigationTree())
					{
						this._fireEvent("navigationchange");
					}	
                ]]></body>
			</method>				
			
			<method name="_fireEvent">
				<parameter name="name" />
				<body><![CDATA[			
					var evt = document.createEvent("Event");
					evt.initEvent(name, true, true);
					this.dispatchEvent(evt);
				]]></body>
			</method>
			
			<method name="getNavigationPath">
				<body><![CDATA[
					var path = [];		
					if (this._selectedNodes.length != 1) {path;};
					var node = this._selectedNodes[0];					
					while (node) 
					{
						if (node.itemData) {path.unshift(node.itemData);}
						node = node.parentNode;
					}
					return path;				
				]]></body>
			</method>
			
			<method name="getSelectedItems">
				<body><![CDATA[
					var selection = [];
					for( var i = 0; i < this._selectedNodes.length; i++)
					{
						var node = this._selectedNodes[i];
						if (node.itemData) {selection.push(node.itemData);}
					}
					return selection;				
				]]></body>
			</method>						
					
			<method name="onDrop">
				<parameter name="element" />
				<parameter name="data" />
				<body><![CDATA[
					try
                    {
                        if (this.getSelectedComponents())
                        {
                            var event = this.getDragEvent();
                            var selectedComponent = this.getSelectedComponents().document[0];
                            for (var i = 0; i < data.length; i++)
                            {
                                switch (data[i].flavour)
                                {
                                    case "application/x-moz-file":
                                        this.doDropFile(
                                            data[i].data,
                                            selectedComponent,
                                            event
                                        );
                                        break;

                                    case "listitem/component":
                                        this.doOnDrop(
                                            data[i].data,
                                            selectedComponent,
                                            event
                                        );
                                        break;
                                }
        				    }
        				    
        				    this.buildE4XSelection();
        				    
            				this.setAvailableActions('select');

            				var ids = this.getSelectedIds();
            				ids.sort();
            				this.setAttribute('selectedids', ids.join(' '));

            				this.setAttribute('selectedcomponents', this.getSelectedComponents().toString());
            				this.handleSelect();
        				}
                    }
                    catch (e)
                    {
                        wCore.error("wBaseList.onDrop", [element, data], e);
                    }
                ]]></body>
			</method>


			<method name="doDropFile">
				<parameter name="fileData" />
				<parameter name="targetComponent" />
				<parameter name="event" />
				<body><![CDATA[
					try
                    {
    				    for (var i = 0; i < fileData.length; i++)
    				    {
    				        var file = fileData[i];
    				        var fileName = file.value.QueryInterface(Components.interfaces.nsIFile).leafName;
    				        wToolkit.startUploadFile(
                                file.value.QueryInterface(Components.interfaces.nsIFile),
                                targetComponent,
                                this
                            );
    				    }
    				}
    				catch (e)
                    {
                        wCore.error("wBaseList.doDropFile", [fileData, targetComponent, event], e);
                    }
                ]]></body>
			</method>


			<method name="onUploadSuccess">
				<parameter name="xmlData" />
				<parameter name="httpRequest" />
				<body><![CDATA[
					try
                    {
    				    wToolkit.successUploadFile(
    				        xmlData.filename.toString(),
    				        this
    				    );
    				    try
    				    {
    				        var module = this.getModule();
    						module.refreshAll();
    					}
    					catch (e)
    					{

    					}
        		    }
    				catch (e)
                    {
                        wCore.error("wBaseList.onUploadSuccess", [xmlData, httpRequest], e);
                    }
                ]]></body>
			</method>


			<method name="onUploadError">
				<parameter name="xmlData" />
				<parameter name="httpRequest" />
				<body><![CDATA[
					try
                    {
    				    wToolkit.errorUploadFile(
    				        xmlData.filename.toString(),
    				        xmlData.message.toString(),
    				        this
    				    );
    				}
    				catch (e)
                    {
                        wCore.error("wBaseList.onUploadError", [xmlData, httpRequest], e);
                    }
                ]]></body>
			</method>

			<method name="doOnDrop">
				<parameter name="sourceComponents" />
				<parameter name="targetComponent" />
				<parameter name="event" />
				<body><![CDATA[
					event.stopPropagation();
					wCore.debug("doOnDrop");
					var srcTypesAssoc = [ ], srcTypes = [ ];
					for (var i = 0 ; i < sourceComponents.document.length() ; i++)
					{
						var type = sourceComponents.document[i].component.(@name=="type").toString();
						if ( ! (type in srcTypesAssoc) )
						{
							srcTypes.push(type);
							srcTypesAssoc[type] = true;
						}
					}
										
					var targetType = targetComponent.component.(@name=="type").toString()
					var actions = this.getDropActions(srcTypes, targetType);
					if (actions.length == 1 && !this.alwaysUseDropPopup)
					{
						this.getModule()[actions[0]](sourceComponents, targetComponent, this);
					}
					else if (actions.length > 1 || (actions.length == 1 && this.alwaysUseDropPopup))
					{
						var thisModule = this.getModule();
						var popup = this.getElementById('dropActionsPopup');

						var itemCount = popup.childNodes.length;
						for (var c = 0 ; c < itemCount ; c++)
						{
							popup.removeChild(popup.childNodes[0]);
						}

						for (var a = 0 ; a < actions.length ; a++)
						{
							var menuitem = document.createElement('menuitem');
							menuitem.setAttribute('label', thisModule.getActionInformation(actions[a]).label);
							menuitem.setAttribute('image', thisModule.getActionInformation(actions[a]).image);
							menuitem.setAttribute('class', 'menuitem-iconic');
							var handler = {
								module     : thisModule,
								method     : actions[a],
								sourceComponents : sourceComponents,
								targetComponent  : targetComponent,
								listWidget       : this,
								handleEvent: function() {
									this.module[this.method](this.sourceComponents, this.targetComponent, this.listWidget);
								},
							};
							menuitem.addEventListener('command', handler, false);
							popup.appendChild(menuitem);
						}
						popup.showPopup(this.tree, event.screenX, event.screenY, "popup");
					}
				]]></body>
			</method>


			<method name="getDropActions">
				<parameter name="sourceTypes" />
				<parameter name="targetType" />
				<body><![CDATA[
					var resultActions = [ ];
					var eventType = 'drop';
					if ( (targetType in this._availableActions) && (eventType in this._availableActions[targetType]) )
					{
						for (var i = 0; i < sourceTypes.length; i++)
						{
							var srcType = sourceTypes[i];

							if (srcType in this._availableActions[targetType][eventType])
							{
								if (i == 0)
								{
									for (var k = 0; k < this._availableActions[targetType][eventType][srcType].length; k++)
									{
										resultActions.push(this._availableActions[targetType][eventType][srcType][k]);
									}
								}
								else
								{
									var actions = this._availableActions[targetType][eventType][srcType];
									var tmp = [ ];
									for (var a = 0 ; a < actions.length ; a++)
									{
										for (var b = 0 ; b < resultActions.length ; b++)
										{
											if (resultActions[b] == actions[a])
											{
												tmp.push(actions[a]);
											}
										}
									}
									resultActions = tmp;
								}
							}
							else
							{
								resultActions = [ ];
								break;
							}
						}
					}

					return resultActions;
				]]></body>
			</method>


			<method name="onActionSuccess">
				<parameter name="response" />
				<body><![CDATA[
					this.refresh(null, true);
				]]></body>
			</method>


		</implementation>

		<handlers>
			<handler event="keypress" keycode="VK_F1" phase="capturing"
				preventdefault="true"><![CDATA[
					event.stopPropagation();
					this.openPreviewPanel();
				]]></handler>

			<handler event="keypress" modifiers="control" key="r"
				preventdefault="true"><![CDATA[
				if (!this.checkEventTarget(event))
				{
					return;
				}
				this.refresh();
			]]></handler>


			<handler event="keypress" keycode="VK_F5"
				preventdefault="true" phase="capturing"><![CDATA[
				if (!this.checkEventTarget(event))
				{
					return;
				}
				event.stopPropagation();
				this.refresh();
			]]></handler>


			<handler event="keypress" modifiers="control" key="a"
				preventdefault="true"><![CDATA[
				if (!this.checkEventTarget(event))
				{
					return;
				}
				this.handleSelectAll();
			]]></handler>


			<handler event="keypress" modifiers="control" key="c"
				preventdefault="true"><![CDATA[
				if (!this.checkEventTarget(event))
				{
					return;
				}
				this.handleCopy();
			]]></handler>


			<handler event="keypress" modifiers="control" key="x"
				preventdefault="true"><![CDATA[
				if (!this.checkEventTarget(event))
				{
					return;
				}
				this.handleCut();
			]]></handler>


			<handler event="keypress" modifiers="control" key="v"
				preventdefault="true"><![CDATA[
				if (!this.checkEventTarget(event))
				{
					return;
				}
				this.handlePaste();
			]]></handler>


			<handler event="keypress" keycode="VK_RETURN"
				preventdefault="true" phase="capturing"><![CDATA[
				if (!this.checkEventTarget(event))
				{
					return;
				}
				event.stopPropagation();
				this.setAttribute('editcomponent', this.getSelectedComponents().toString());
				this.handleDoubleClick();
			]]></handler>


			<handler event="click" clickcount="1"><![CDATA[
			    if (event.originalTarget.tagName == "treecol")
			    {
			        this.handleTreeSort(event, event.originalTarget);
			        return;
			    }
			    this._preventSelectionRecursion = false;
				if (!this.checkEventTarget(event))
				{
					return;
				}
				this.toggleOpenState(event, true);
			]]></handler>


			<handler event="click" clickcount="2" preventdefault="true"
				phase="capturing"><![CDATA[
			    this._preventSelectionRecursion = false;

			    if (!this.checkEventTarget(event))
				{
					return;
				}

				if (!this.isList())
                {
                    this._currentOffset = -1;
				}

				this.toggleOpenState(event, false);
				event.stopPropagation();
				var components = this.getSelectedComponents();
				if (!components || !components.document || (components.document.length() == 0))
				{
					return;
				}

				var doc = this.getSelectedComponents().document[0];
				var type = doc.component.(@name=="type").toString();
				var id   = doc.component.(@name=="id").toString();
				var perm = doc.component.(@name=="permissions").toString();
				if (perm != 'allpermissions' && perm.indexOf(',edit,') == -1)
				{
					return;
				}

				if (this.isList() && (type == "go_to_parent_folder") && (id > 0))
				{
					this._dataSource["root"] = id;
					this.abortLoading();
					if (this._loadTimeOut)
		        		{
		        			clearTimeout(this._loadTimeOut);
		        		}
		            		this._loadTimeOut = setTimeout(function(xbl){ xbl._load(); }, this.default_load_timeout, this);
					// this._load();
				}
				else
				{
				    	var editComponentValue = this.getSelectedComponents().toString();
					if (editComponentValue == this.getAttribute('editcomponent'))
					{
						this.removeAttribute('editcomponent');
					}
					this.handleDoubleClick();
				}
			]]></handler>

			<handler event="contextmenu" phase="capturing"><![CDATA[
				if (!this.checkEventTarget(event))
				{
					// stop event only on separators :
					var selectedIndex = this.tree.view.selection.currentIndex;
                    if (selectedIndex >= 0)
                    {
        				var selectedNode = this.tree.view.getItemAtIndex(selectedIndex);
        			    if (selectedNode && selectedNode.tagName
        			    	&& (selectedNode.tagName.toLowerCase() == "treeseparator"))
            			{
            				event.preventDefault();
							event.stopPropagation();
            			}
            		}
					return;
				}
				this.setAvailableActions('contextmenu');
			]]></handler>


			<handler event="select"><![CDATA[
				if (!this.checkEventTarget(event))
				{
					return;
				}
				var selectedIndex = this.tree.view.selection.currentIndex;
                if (selectedIndex >= 0)
                {
			        var selectedNode = this.tree.view.getItemAtIndex(selectedIndex);
			        if (selectedNode.itemData && (selectedNode.itemData.cutInDepth == true) && !this.isList())
			        {
			        	if (this._loadTimeOut)
			        	{
			        		clearTimeout(this._loadTimeOut);
			        	}
			            this._loadTimeOut = setTimeout(function(xbl){ xbl._load(selectedNode, false); }, this.default_load_timeout, this);
			        }
			    }

			    this.buildE4XSelection();
			    
				if (this._preventSelectionRecursion == false)
				{
    				this.setAvailableActions('select');

    				var ids = this.getSelectedIds();
        			ids.sort();
    				this.setAttribute('selectedids', ids.join(' '));

    				this.setAttribute('selectedcomponents', this.getSelectedComponents().toString());
    				this.handleSelect();
    		    }
    		    else
    		    {
    		        this._preventSelectionRecursion = false;
    		    }
    		    
    		    if (this._relatedBinding != undefined && 'onSelect' in this._relatedBinding)
			   	{
			   		this._relatedBinding.onSelect(this);
			   	}   		    
			]]></handler>


		</handlers>

		<xbl:content
			xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
			xmlns:xbl="http://www.mozilla.org/xbl">

			<vbox flex="1" xbl:inherits="flex">

				<toolbox anonid="top-toolbox" orient="horizontal"
					dir="normal" class="change-toolbox-light" xbl:inherits="collapsed=disabletoolbox">

					<!-- language entry : -->

					<toolbar anonid="languagetb" flex="1"
						orient="horizontal" dir="normal" class="change-toolbar">

						<spacer anonid="languagetb-spacer" flex="1"
							collapsed="true" />

						<hbox align="center">
							<menulist class="tree-language"
								sizetopopup="none" src="{IconsBase}/small/environment.png"
								anonid="supportedlanguages" width="90"
								oncommand="languageSelect()">
								<menupopup />
							</menulist>
						</hbox>

					</toolbar>

					<!-- full tree navigation entries :  -->

					<toolbar anonid="navigationtb" flex="1"
						collapsed="true" orient="horizontal" dir="normal"
						class="change-toolbar">
						<spacer anonid="navigationspacer" flex="1" />
						<toolbarbutton anonid="navigationbegin"
							image="{IconsBase}/small/shadow/navigate_beginning.png"
							disabled="true"
							tooltiptext="&amp;modules.uixul.bo.general.Navigate-begin;"
							oncommand="navigateBegin()" />
						<toolbarbutton anonid="navigationback2"
							image="{IconsBase}/small/shadow/navigate_left2.png"
							disabled="true"
							tooltiptext="&amp;modules.uixul.bo.general.Navigate-back-quick;"
							oncommand="navigateBack(true)" />
						<toolbarbutton anonid="navigationback"
							image="{IconsBase}/small/shadow/navigate_left.png"
							disabled="true"
							tooltiptext="&amp;modules.uixul.bo.general.Navigate-back;"
							oncommand="navigateBack()" />
						<hbox align="center">
							<label anonid="navigationpagelabel"
								value="&amp;modules.uixul.bo.general.Page;" />
							<menulist anonid="navigationindex"
								sizetopopup="none" editable="true" width="50"
								oncommand="navigateSelect()" oninput="navigateInput()"
								height="22">
								<menupopup />
							</menulist>
							<label anonid="navigationpageseparator"
								value="&amp;modules.uixul.bo.general.out-of;" />
							<label anonid="navigationtotal" value="0" />
						</hbox>
						<toolbarbutton anonid="navigationnext"
							image="{IconsBase}/small/shadow/navigate_right.png"
							tooltiptext="&amp;modules.uixul.bo.general.Navigate-next;"
							oncommand="navigateNext()" />
						<toolbarbutton anonid="navigationnext2"
							image="{IconsBase}/small/shadow/navigate_right2.png"
							tooltiptext="&amp;modules.uixul.bo.general.Navigate-next-quick;"
							oncommand="navigateNext(true)" />
						<toolbarbutton anonid="navigationend"
							image="{IconsBase}/small/shadow/navigate_end.png"
							tooltiptext="&amp;modules.uixul.bo.general.Navigate-end;"
							oncommand="navigateEnd()" />
						<spacer flex="1" />
					</toolbar>

					<!-- tree filter entry : -->

					<toolbar anonid="filtertb" flex="1"
						orient="horizontal" dir="normal" class="change-toolbar" xbl:inherits="collapsed=disablefilter">

						<spacer flex="1" />

						<hbox align="center">
							<menulist class="tree-filter"
								sizetopopup="none" anonid="filtertext" editable="true"
								width="90" oncommand="filterSelect()" oninput="filterInput()">
								<menupopup>
									<menuitem label="" />
									<menuitem label="id:" />
									<menuitem label="lang:" />
									<menuitem label="type:" />
									<menuitem label="author:" />
									<menuitem label="status:" />
								</menupopup>
							</menulist>
						</hbox>

					</toolbar>

				</toolbox>

				<tree anonid="tree" hidecolumnpicker="true"	selstyle="primary" flex="1"
					xbl:inherits="disabled,collapsed,hidden,style,seltype,selstyle,hidecolumnpicker,class,ref,hideheader"
					editable="true">
					<treecols anonid="treecols">
						<treecol type="checkbox" anonid="check-column"
							label="&amp;modules.uixul.bo.general.Selector;" hidden="true"
							xbl:inherits="hideheader" class="treecol-image"
							src="{IconsBase}/small/checkbox_empty.png" editable="true"
							tooltiptext="&amp;modules.uixul.bo.general.Selector-tooltip;"
							style="padding-right: 5px;" />
						<treecol anonid="id-column"
							label="&amp;modules.uixul.bo.general.Id;" hidden="true"
							xbl:inherits="hideheader"
							tooltiptext="&amp;modules.uixul.bo.general.Id-tooltip;"
							class="treecol-image" src="{IconsBase}/small/key2.png"
							style="padding-right: 5px;" width="70px" />
						<treecol anonid="pub-column"
							label="&amp;modules.uixul.bo.general.Publicated;" hidden="true"
							xbl:inherits="hideheader" class="treecol-image"
							src="{IconsBase}/small/eyeglasses.png"
							tooltiptext="&amp;modules.uixul.bo.general.Publicated-tooltip;"
							style="padding-right: 5px;" />
						<treecol flex="3" anonid="main-column"
							primary="true" xbl:inherits="hideheader" />
					</treecols>
					<treechildren anonid="treechildren" />
				</tree>
				<vbox anonid="list-items" class="custombaselist" collapsed="true" flex="3">					
				</vbox>
				<wpreviewpanel anonid="previewPanel" collapsed="true" />
				<wtagspanel anonid="tagsPanel" blocking="true" collapsed="true" />
				<splitter collapsed="true" />
				<vbox flex="1" collapsed="true" name="panelContainer">
					<worderchildrenpanel anonid="orderChildrenPanel"
						flex="1" collapsed="true" />
				</vbox>
			</vbox>
			<popup anonid="dropActionsPopup" />
		</xbl:content>
	</binding>
</bindings>
