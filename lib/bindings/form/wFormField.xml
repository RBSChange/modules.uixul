<?xml version="1.0"?>
<bindings
	xmlns="http://www.mozilla.org/xbl"
	xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul">

<!--
################################################################################
## wFormField                                                                 ##
################################################################################
-->

	<binding id="wFormField" extends="core.wBox#wBox">

		<implementation>

<!--
	### wFormField FIELDS ######################################################
-->

			<field name="isFormField" readonly="true">true</field>
			
			<field name="_original_value">null</field>

			<field name="block_change_events">false</field>

			<!-- The constraints array defined for the field -->
			<field name="_constraints">null</field>

			<!-- The timeout ID returned by window.setTimeout() -->
			<field name="serverside_validation_timeout_id">null</field>

			<!-- The timeout ID returned by window.setTimeout() FOR VALIDATION ON INPUT -->
			<field name="input_validation_timeout_id">null</field>

			<!-- Default timeout for INPUT validation, in milliseconds -->
			<field name="default_input_validation_timeout">250</field>

			<!-- Indicates whether the field needs a server side validation -->
			<field name="needs_serverside_validation">false</field>

			<!-- Default timeout for the server side validation, in milliseconds -->
			<field name="default_serverside_validation_timeout">500</field>

			<!-- The XUL element that is the alternate input field. -->
			<field name="suggestion_input_field">null</field>

			<!-- The parent wform element -->
			<field name="_parent_form">null</field>

			<!-- The parent wfieldgroup element -->
			<field name="_parent_group">null</field>

			<!-- The validation errors collection -->
			<field name="validationErrors">null</field>

			<field name="_help_text">null</field>


			<!-- Returns the parent form object. -->
			<property name="form" readonly="true">
				<getter><![CDATA[
					return this._parent_form;
				]]></getter>
			</property>


			<!-- Returns the parent fieldgroup object. -->
			<property name="fieldGroup" readonly="true">
				<getter><![CDATA[
					return this._parent_group;
				]]></getter>
			</property>

			<property name="disabled" readonly="true">
				<getter><![CDATA[
					return this.hasAttribute('disabled') && this.getAttribute('disabled') == 'true';
				]]></getter>
			</property>


			<!-- Disables the field. -->
			<method name="disable">
				<body><![CDATA[
					this.setAttribute('disabled', 'true');
					this.validate();
				]]></body>
			</method>


			<!-- Enables the field. -->
			<method name="enable">
				<body><![CDATA[
					this.removeAttribute('disabled');
					this.validate();
				]]></body>
			</method>


			<!-- Returns the name of the field. -->
			<property name="name" readonly="true">
				<getter><![CDATA[
					return this.getAttribute('name');
				]]></getter>
			</property>

			<!-- Returns the localized label of the field. -->
			<property name="label" readonly="true">
				<getter><![CDATA[
					if (this.hasAttribute('label'))
					{
						return this.getAttribute('label');
					}
					return this.name;
				]]></getter>
			</property>


			<!-- Returns the XUL element that is really the input field. -->
			<property name="input_field">
				<getter><![CDATA[
					return this.getElementById('inputField');
				]]></getter>
			</property>


			<!--
			Returns or sets the value of the field.
			Setting a value with this property will call the validation process of the field.
			-->
			<property name="value">
				<getter><![CDATA[
					//wCore.debug("wFormField.value getter "+this.name);
					if (this.input_field)
					{
						return this.input_field.value;
					}
					return null;
				]]></getter>
				<setter><![CDATA[
					//wCore.debug("wFormField.value setter "+this.name+" "+val);
					if (this.input_field)
					{
						if (this.input_field.value != val)
						{
							this.input_field.value = val;
							this.validate();
						}
					}
				]]></setter>
			</property>

			<!--  Sets the alternate value of the field. -->
			<property name="suggestionValue">
				<setter><![CDATA[
				    if (!this.suggestion_input_field)
					{
					    this.suggestion_input_field = this.getElementById('suggestionInputField');
					}
					if (this.suggestion_input_field && 'destroy' in this.suggestion_input_field)
					{
					    if (val == null)
					    {
					       this.suggestion_input_field.destroy();
					    }
					    else
					    {
					       this.suggestion_input_field.initialize(val, this);
					    }
					}
				]]></setter>
			</property>


			<!-- Returns the default value set for the field with the 'default-value' attribute. -->
			<property name="defaultValue">
				<getter><![CDATA[
					if (this.hasDefaultValue)
					{
						return this.getAttribute('default-value');
					}
					return null;
				]]></getter>
			</property>


			<!-- Indicates whether the field has a default value or not. -->
			<property name="hasDefaultValue">
				<getter><![CDATA[
					return this.hasAttribute('default-value');
				]]></getter>
			</property>


			<!-- Returns the type of the field (its tagName). -->
			<property name="type" readonly="true">
				<getter><![CDATA[
					return this.tagName;
				]]></getter>
			</property>


			<!-- Indicates whether the field validates or not. -->
			<property name="isValid">
				<getter><![CDATA[
					return parseBoolean(this.getAttribute('validates'));
				]]></getter>
			</property>


			<!-- Timeout after which the server side validation process is called. -->
			<property name="timeout" readonly="true">
				<getter><![CDATA[
					var timeout = 0;
					if (this.hasAttribute('timeout'))
					{
						timeout = parseInt(this.getAttribute('timeout'));
					}
					if (!timeout)
					{
						timeout = this.default_serverside_validation_timeout;
					}
					return timeout;
				]]></getter>
			</property>


			<!-- Indicates whether the debug mode is enabled or not. -->
			<property name="debugEnabled">
				<getter><![CDATA[
					return (this.hasAttribute('debug') && this.getAttribute('debug') == 'true') || this.form.debugEnabled;
				]]></getter>
			</property>


			<!--
			Indicates if the field has been modified since the last call to setCurrentValueAsDefault(),
			or since the last load.
			-->
			<property name="hasModifications">
				<getter><![CDATA[
					var hasModif = false;
					var value = this.value;
					if (value != this._original_value)
					{
						if (this._original_value === null)
						{
							hasModif = (value.length > 0);
						}
						else if (typeof(value) == 'object' && typeof(this._original_value) == 'object')
						{
							if (value.length != this._original_value.length)
							{
								hasModif = true;
							}
							else
							{
								for (var i = 0; i < value.length && !hasModif; i++)
								{
									hasModif = value[i] != this._original_value[i];
								}
							}
						}
						else
						{
							hasModif = true;
						}
					}
					return hasModif;
				]]></getter>
			</property>


			<property name="helpText">
				<getter><![CDATA[
					if (this._help_text == null)
					{
						for (var c=0 ; c<this.childNodes.length && this._help_text == null ; c++)
						{
							if (this.childNodes[c].tagName == 'whelp' || this.childNodes[c].tagName == 'xul:whelp')
							{
								this._help_text = this.childNodes[c].textContent;
							}
						}
						if (this._help_text == null)
						{
							this._help_text = '';
						}
					}
					return this._help_text;
				]]></getter>
			</property>


			<property name="required">
				<getter><![CDATA[
         			return this.hasAttribute('required') && this.getAttribute('required') == 'true';
				]]></getter>
			</property>


			<property name="readonly">
				<getter><![CDATA[
         			return this.hasAttribute('readonly') && this.getAttribute('readonly') == 'true';
				]]></getter>
				<setter><![CDATA[
					if (val)
					{
						this.setAttribute('readonly', 'true');
					}
					else
					{
						this.removeAttribute('readonly');
					}
				]]></setter>
			</property>


			<property name="editOnce" readonly="true">
				<getter><![CDATA[
					return this.getAttribute('editonce') == 'true';
				]]></getter>
			</property>


			<!-- Constructor of each form field. -->
			<constructor><![CDATA[
				this.init_parent_form();
				// Finds constraints to apply to this field.
				this.init_constraints();
				this.initialize();
				this.init_initial_value();
				this.handleEditOnce();
			]]></constructor>
			
			<!-- Initialization of parent form. -->
			<method name="init_parent_form">
				<body><![CDATA[
					if (this.find_parent_form() == true)
					{
						if (!this.form.register_field(this) )
						{
							this._parent_form = null;
						}
					}
					else
					{
						throw new Error("[wFormField "+this.tagName+"] "+this.name+": could not find parent form.");
					}
				]]></body>
			</method>
						

			<method name="init_constraints">
				<body><![CDATA[
					for (var c=0 ; c<this.childNodes.length ; c++)
					{
						var child = this.childNodes[c];
						if (child.tagName == 'constraint' || child.tagName == 'xul:constraint')
						{
							if (!child.hasAttribute('name'))
							{
								throw new Error('<constraint/> element must have a "name" attribute for field "'+this.name+'" in the form ID="'+this.form.id+'" (model="'+this.form.documentModelName+'"). Example: <constraint name="range">6..12</constraint>');
							}
							var name = child.getAttribute('name');
							if (trim(name).length == 0)
							{
								throw new Error('The "name" attribute on <constraint/> element must NOT be empty for field "'+this.name+'" in the form ID="'+this.form.id+'" (model="'+this.form.documentModelName+'"). Example: <constraint name="range">6..12</constraint>');
							}
							
							if (this._constraints === null) 
							{
								this._constraints = [ ];
							}
							this.addConstraint(name, child.textContent);
							if (!wValidation.validatorExists(name) )
							{
								this.needs_serverside_validation = true;
							}
						}
					}
				]]></body>
			</method>
			
			<!-- Global initialization of the field. FATAL wFormField ONLY INITIALIZED-->
			<method name="initialize" >
				<body><![CDATA[
				]]></body>
			</method>
			
			
			<!-- Initialization of initial (default) value. -->
			<method name="init_initial_value">
				<body><![CDATA[
					if ( this.hasAttribute('value') )
					{
						this._original_value = this.getAttribute('value');
						this.value = this._original_value;
					}
					else if (this.hasDefaultValue)
					{
 						wCore.debug(this.name + ' has a default value: ' + this.defaultValue);
						this.value = this.defaultValue;
					}
					else
					{
						this.validate();
					}
				]]></body>
			</method>
			
			<!--  Global initialization of the field. -->
			<method name="handleEditOnce">
				<body><![CDATA[
					if (this.editOnce)
					{
						this.readonly = !this.form.isNew();
					}
				]]></body>
			</method>


			<!-- Finds the parent wForm object and set 'this._parent_form' -->
			<method name="find_parent_form">
				<body><![CDATA[
					if (this._parent_form == null)
					{
						var node = this.parentNode;
						while (node != null)
						{
							var tagName = node.tagName;
							if (tagName == "wform" || tagName == "wwizard" || tagName == "wpropertygrid")
							{
								this._parent_form = node;
								break;
							}
							else if ('registerFieldInGroup' in node)
							{
								node.registerFieldInGroup(this);
							}
							node = node.parentNode;
						}
					}
					return (this._parent_form != null);
				]]></body>
			</method>


			<!-- Calls the validation process and update the UI consequently. -->
			<method name="validate">
				<body><![CDATA[
					var v;
					if (!this.disabled)
					{	
						v = this.doValidate();
					}
					else
					{
						v = true;
					}
					
					this.set_is_valid(v);
					return v;
				]]></body>
			</method>


			<!-- Specific validation process of the field. -->
			<method name="doValidate">
				<body><![CDATA[
					return this._validate_constraints();
				]]></body>
			</method>


			<!-- Validates the constraints of the field. -->
			<method name="_validate_constraints">
				<body><![CDATA[
					if (this.needs_serverside_validation)
					{
						var timeout = this.timeout;
						if (this.hasAttribute('validate-notimeout')) {
							timeout = 0;
						}
						if (timeout == -1)
						{
							return false;
						}
						
						// Here I use a very smart capabilities of JavaScript: closures
						// See http://www.jibbering.com/faq/faq_notes/closures.html for a great
						// documentation about this.
						var callLater = function(obj, method) {
							return function() { return obj[method](); }
						}

						// clear the timeout if a previous server validation call is planned
						if (this.serverside_validation_timeout_id)
						{
							window.clearTimeout(this.serverside_validation_timeout_id);
						}

						// plan new server validation call
						this.setAttribute('validating', 'true');
						this.serverside_validation_timeout_id = window.setTimeout(callLater(this, '_server_side_validate'), timeout);

						return false;
					}
					else
					{
						return this._client_side_validate();
					}
				]]></body>
			</method>


			<!-- Does a client side validation of the field. -->
			<method name="_client_side_validate">
				<body><![CDATA[
					var errors = new validation_Errors();
					var warnings = new validation_Errors();
					if (this._constraints !== null)
					{
						var property = new validation_Property(this.label, this.value ? this.value : '');

						// First let's validate the 'blank' constraint if it exists.
						for (var name in this._constraints)
						{
							if ( name == 'blank' )
							{
								var v = wValidation.getValidator(name);
								v.setParameter(wValidation.getValidatorParameter(this._constraints[name]));
								v.validate(property, errors);
							}
						}

						// If there is no error and if the value is not empty, we
						// must check the other constraints.
						if (errors.length == 0 && (property.value || property.value.length) )
						{
							for (var name in this._constraints)
							{
								// Well, if there is a BlankValidator, it has been validated before
								if ( name != 'blank' )
								{
									var v = wValidation.getValidator(name);
									v.setParameter(wValidation.getValidatorParameter(this._constraints[name]));
									v.validate(property, errors);
								}
							}
						}
					}
					if (errors.length)
					{
						this.validationErrors = errors;
						if (this.form)
						{
							this.form.setErrors(this, errors);
						}
					}
					else
					{
						this.validationErrors = null;
					}
					return errors.length === 0;
				]]></body>
			</method>


			<!-- Does a server side validation of the field. 
				All constraints are checked server side within this single call, even the ones that can be check on the client. 
				The field is considered as non-valid until the server responds: the method always returns false. -->
			<method name="_server_side_validate" >
				<body><![CDATA[
					var constraintsString = '';
					for (var name in this._constraints)
					{
						constraintsString += name + ':' + this._constraints[name] + ';' ;
					}
					this.setAttribute('validating', 'true');

					var param = [ ];
					param['data'] = this.value;
					param['constraints'] = constraintsString;
					param['name'] = this.label;

					if (this.form)
					{
						if (this.form.document)
						{
							param['{K::COMPONENT_ID_ACCESSOR}'] = this.form.document.id;
						}
						else
						{
							param['documentModel'] = this.form.documentModelName;
						}
						param['{K::PARENT_ID_ACCESSOR}'] = this.form.getDestinationParentId();
					}

					param['documentProperty'] = this.name;

					this.getController().execute(
						'&modules.uixul.bo.messages.Field-validation;',
						this, '{K::GENERIC_MODULE_NAME}', 'ValidateConstraints', param
						);
					// For the moment, the field is considered as not valid:
					return false;
				]]></body>
			</method>
			
			<method name="onValidateConstraintsSuccess">
				<body><![CDATA[
					this.removeAttribute('validating');
					this.validationErrors = null;
					this.set_is_valid(true);
				]]></body>
			</method>

			<method name="onValidateConstraintsError">
				<parameter name="e4x" />
				<body><![CDATA[
					this.removeAttribute('validating');
					this.validationErrors = [ e4x.message.toString() ];
					this.set_is_valid(false);
				]]></body>
			</method>


			<!-- Update the UI from a validation result given as first parameter. -->
			<method name="set_is_valid" >
				<parameter name="bool" />
				<body><![CDATA[
					var currentValidationState = parseBoolean(this.getAttribute('validates'));
					if (bool == true || this.disabled)
					{
						this.setAttribute('validates', 'true');
						// intbonjf 2007-04-19:
						// if (currentValidationState !== bool)
						this.onValidateSuccess();
					}
					else
					{
						this.setAttribute('validates', 'false');
						// intbonjf 2007-04-19:
						// if (currentValidationState !== bool)
						this.onValidateError();
					}

					// intbonjf 2007-04-19:
					if (currentValidationState !== bool)
					{
						this.onValidateStatusChanged();
					}
					
					//TODO USE raiseChange ?
					if (this.form)
					{
						this.form.revalidate();
						if (this.hasAttribute('focused'))
						{
							this.form.showFieldInfo(this);
						}
						if ('updateTab' in this.form)
						{
							this.form.updateTab(this);
						}
					}
					
					if (this.fieldGroup)
					{
						this.fieldGroup.revalidate();
					}
				]]></body>
			</method>

			<!-- Called each time the validation process validates the field. -->
			<method name="onValidateSuccess">
				<body><![CDATA[
				]]></body>
			</method>

			<!-- Called each time the validation process does NOT validate the field. -->
			<method name="onValidateError">
				<body><![CDATA[
				]]></body>
			</method>

			<!-- Called each time the field's validation status changes. -->
			<method name="onValidateStatusChanged">
				<parameter name="e4x" />
				<body><![CDATA[
				]]></body>
			</method>

			<method name="setCurrentValueAsDefault" >
				<body><![CDATA[
					this._original_value = this.value;
				]]></body>
			</method>


			<method name="reset">
				<body><![CDATA[
					this.doReset();
					this.handleEditOnce();
				]]></body>
			</method>


			<!--

			-->
			<method name="empty">
				<body><![CDATA[
					this.doEmpty();
					this.handleEditOnce();
				]]></body>
			</method>


			<!-- Resets the field value. -->
			<method name="doReset">
				<body><![CDATA[
					if ( this._original_value && this._original_value.length )
					{
						this.value = this._original_value;
					}
					else
					{
						this.doEmpty();
					}
				]]></body>
			</method>


			<!-- Empties the field. -->
			<method name="doEmpty">
				<body><![CDATA[
					if (this.hasDefaultValue)
					{
						this.value = this.defaultValue;
					}
					else
					{
						//this.input_field.value = '';
						this.value = '';
					}
				]]></body>
			</method>


			<method name="setupFormObserver">
				<parameter name="targetId" />
				<body><![CDATA[
					if (!targetId) {
						targetId = 'inputField';
					}
					var observes = document.createElement('observes');
					observes.setAttribute('element', this.form.id);
					observes.setAttribute('attribute', 'disabled');
					this.getElementById(targetId).appendChild(observes);
				]]></body>
			</method>

			<method name="addConstraint">
				<parameter name="name" />
				<parameter name="parameter" />
				<body><![CDATA[
					wCore.debug("addConstraint :" + name + ", " + parameter);
					if ( name in this._constraints )
					{
						throw new Error('Constraint "' + name + '" already exist for field "' + this.name + '" with value "' + this._constraints[name].toString() + '".');
					}

					this._constraints[name] = parameter;
					var required = false;
					if ( (name == 'blank' && parameter == 'false') || (name == 'minSize' && parseInt(parameter) > 0) )
					{
						required = true;
					}
					else if (name == 'size')
					{
						if ( (parameter instanceof validation_Range && parameter.min > 0) || (parseInt(parameter) > 0) )
    					{
    						required = true;
        				}
        			}
        			if (required)
        			{
        				this.setAttribute('required', 'true');
        			}
				]]></body>
			</method>


			<method name="hasValidationErrors">
				<body><![CDATA[
					return this.validationErrors != null && this.validationErrors.length > 0;
				]]></body>
			</method>



			<method name="getValidationErrors">
				<body><![CDATA[
					return this.validationErrors;
				]]></body>
			</method>

			<method name="raiseChangeEvent">
				<body><![CDATA[
					this.raiseEvent("change");
				]]></body>
			</method>

			<method name="raiseEvent">
				<parameter name="eventName" />
				<body><![CDATA[
					if (!this.block_change_events || eventName != 'change')
					{
						var evt = document.createEvent("HTMLEvents");
						evt.initEvent(eventName, true, true);
						this.dispatchEvent(evt);
					}
				]]></body>
			</method>
		</implementation>

		<handlers>
			<handler event="input"><![CDATA[
				if (this.input_validation_timeout_id)
				{
					window.clearTimeout(this.input_validation_timeout_id);
				}
				var xbl = this;
				this.input_validation_timeout_id = window.setTimeout(function() { xbl.validate(); }, this.default_input_validation_timeout);
			]]></handler>

			<handler event="command"><![CDATA[
			    this.validate();
			]]></handler>

			<handler event="drop"><![CDATA[
				this.validate();
			]]></handler>

	        <handler event="focus" phase="capturing"><![CDATA[
                this.setAttribute('focused', 'true');
                if (this.form)
                {
                	this.form.onFieldFocus(this);
                }
            ]]></handler>

            <handler event="blur" phase="capturing"><![CDATA[
                this.removeAttribute('focused');
                if (this.form)
                {
                	this.form.onFieldBlur(this);
                }
            ]]></handler>
		</handlers>
	</binding>
</bindings>
