<?xml version="1.0"?>
<bindings
	xmlns="http://www.mozilla.org/xbl"
	xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul">

<!--
################################################################################
## wElementPicker                                                             ##
################################################################################
-->

	<binding id="wElementPicker" extends="form.wFormField#wFormField">


		<implementation>

			<field name="SINGLE_SELECTION" readonly="true">"SINGLE"</field>
			<field name="MULTIPLE_SELECTION" readonly="true">"MULTIPLE"</field>

			<field name="LABEL_FORMAT_ATTRIBUTE" readonly="true">"label-format"</field>
			<field name="DEFAULT_LABEL_FORMAT_ATTRIBUTE" readonly="true">"label"</field>

			<field name="_quick_hasModifications">false</field>
			<field name="_newValue">null</field>


			<property name="value">
				<getter><![CDATA[
					return this.input_field.value;
				]]></getter>
				<setter><![CDATA[
					this.clear();
					if (/^\d+(,?\d+)*$/.test(val))
					{
						var ids = val.split(',');
						for (var i = 0; i < ids.length; i++)
						{
						 	var intVal = parseInt(ids[i]);
						    if (!isNaN(intVal) && intVal > 0)
						    {
								this.setValueFromID(intVal);
						    }
						}
					}
				    else
				    {
				    	this.setValueFromXML(new XML(val));
				    }
				]]></setter>
			</property>

			<method name="setValueFromXML">
				<parameter name="e4x" />
				<body><![CDATA[
					for (var i=0 ; i<e4x.document.length() ; i++)
					{
						this.addDocument(e4x.document[i]);
					}
				]]></body>
			</method>

			<method name="setValueFromID">
				<parameter name="id" />
				<body><![CDATA[					
					var items = wCore.getDocumentInfo(id);
					if (items != null)
					{
						if (items.constructor == Array)
						{
							for(var i =0; i < items.length; i++)
							{
								this.addJsDocument(items[i]);
							}
						}
						else
						{
							this.addJsDocument(items);
						}
					}
				]]></body>
			</method>

			<property name="allowedComponents">
				<getter><![CDATA[
					if (this.hasAttribute('allow'))
					{
						return this.getAttribute('allow').split(/[\s,]+/);
					}
					return '*';
				]]></getter>
				<setter><![CDATA[
					this.setAttribute('allow', val);
					this.setupActions();
				]]></setter>
			</property>


			<property name="labelFormat">
				<getter><![CDATA[
					if (this.hasAttribute(this.LABEL_FORMAT_ATTRIBUTE))
					{
						return this.getAttribute(this.LABEL_FORMAT_ATTRIBUTE);
					}
					return this.DEFAULT_LABEL_FORMAT_ATTRIBUTE;
				]]></getter>
			</property>


			<property name="selType">
				<getter><![CDATA[
					if (this.getAttribute('seltype') == 'single')
					{
						return this.SINGLE_SELECTION;
					}
					return this.MULTIPLE_SELECTION;
				]]></getter>
			</property>


			<constructor>
			<![CDATA[
				this.setupActions();
			]]>
			</constructor>


			<method name="setupActions">
				<body><![CDATA[
				if (this.hasAttribute('actions'))
				{
					var buttonArray = {
						'delete' : 'btnDelete',
						'create' : 'btnCreateNew',
						'edit' : 'btnEdit'
					};
					// If the 'actions' attribute is set, it must contain all
					// the desired actions (all other actions are hidden).
					for each (var buttonId in buttonArray)
					{
						this.getElementById(buttonId).hidden = true;
					}
					var extraButtons = false;
					var actionArray = this.getAttribute('actions').split(' ');
					for (var i=0 ; i<actionArray.length ; i++)
					{
						var action = actionArray[i];
						if (action in buttonArray)
						{
							this.getElementById(buttonArray[action]).hidden = false;
							extraButtons = true;
						}
					}
					if (extraButtons)
					{
						this.openExtraButtonsBox();
					}
				}
				else if (this.getAttribute('allow-create-new') == 'true' && this.allowedComponents != '*')
				{
					this.openExtraButtonsBox();
				}
				this.setupCreateButton();
				]]></body>
			</method>


			<method name="setupCreateButton">
				<body><![CDATA[
				// If the user can create sub-documents, and if the element picker
				// allows multiple types of documents, we must provide a listbox
				// for the user to choose which kind of document to create.
				var createNewButton = this.getElementById('btnCreateNew');
				if (this.form && this.allowedComponents != '*' && this.allowedComponents.length > 1 && ! createNewButton.hidden)
				{
					var doc = document;
					var popupId = this.form.id + '_' + this.name + '_popup';
					var popup = doc.createElement('popup');
					popup.setAttribute('id', popupId);

					var xbl = this;
					for (var j=0 ; j<this.allowedComponents.length ; j++)
					{
						var modelName = this.allowedComponents[j];
						var item = doc.createElement('menuitem');
						item.setAttribute('label', this.getAttribute('label-for-' + modelName));
						var handler =
						{
							modelName: modelName,
							handleEvent: function (e) {
								xbl._openSubForm(this.modelName);
							}
						}
						item.addEventListener('command', handler, false);
						popup.appendChild(item);
					}
					this.getElementById('extraButtons').appendChild(popup);
					createNewButton.setAttribute('popup', popupId);
				}
				]]></body>
			</method>


			<method name="openExtraButtonsBox">
				<body><![CDATA[
					var extraButtonsBox = this.getElementById('extraButtons');
					extraButtonsBox.removeAttribute('hidden');
					if (this.selType == this.SINGLE_SELECTION)
					{
						extraButtonsBox.setAttribute('orient', 'horizontal');
					}
				]]></body>
			</method>


            <property name="hasModifications">
				<getter><![CDATA[
					//wCore.debug('hasModifications : ' + this._quick_hasModifications);
					return this._quick_hasModifications;
				]]></getter>
			</property>


			<method name="setCurrentValueAsDefault">
				<body><![CDATA[
					this._original_value = this.value;
					this._quick_hasModifications = false;
					//wCore.debug('setCurrentValueAsDefault');
				]]></body>
			</method>

			<method name="init_initial_value" >
				<body><![CDATA[	
					//wCore.debug('init_initial_value START');				
					if (this.hasAttribute('value') )
					{
						this._original_value = this.getAttribute('value');
						this.value = this._original_value;
					}
					else if (this.hasDefaultValue )
					{
						this.value = this.defaultValue;
					}
					else
					{
						this.validate();
					}
					//wCore.debug('init_initial_value END');
					this._quick_hasModifications = false;
				]]></body>
			</method>
			

			<method name="setMessage">
				<parameter name="msg"/>
				<body><![CDATA[
					if (msg && msg.length > 0)
					{
						this.getElementById("message").setAttribute("value", msg);
						this.getElementById("message").removeAttribute("hidden");
					}
					else
					{
						this.getElementById("message").setAttribute("hidden", "true");
					}
				]]></body>
			</method>


			<method name="addDocument">
				<parameter name="document" />
				<body><![CDATA[
				    if (this.selType == this.SINGLE_SELECTION && this.input_field.nbItems == 1)
					{
						this.clear();
					}
					this.input_field.addItem(document.component.(@name=="id").toString(), this.formatLabel(document));
					this.setModified();
				]]></body>
			</method>
			
			<method name="addJsDocument">
				<parameter name="document" />
				<body><![CDATA[
				    if (this.selType == this.SINGLE_SELECTION && this.input_field.nbItems == 1)
					{
						this.clear();
					}
					
					var id = document.id;
					var label = document.labels[document.lang];
					
					var lang = this.getModule().getContextLang();
					if (document.lang != lang && lang in document.labels)
					{
						var label = document.labels[lang];
					}				
					this.input_field.addItem(id.toString(), label);
					this.setModified();
				]]></body>
			</method>


			<method name="updateDocument">
				<parameter name="document" />
				<body><![CDATA[
					this.input_field.updateItem(document.component.(@name=="id").toString(), this.formatLabel(document));
					this.setModified();
				]]></body>
			</method>


			<method name="hasDocument">
				<parameter name="id" />
				<body><![CDATA[
					if (this.form && this.form.document && this.form.document.id && this.form.document.id == id)
					{
						this.setMessage("&modules.uixul.bo.elementPicker.Document-not-droppable;");
						return true;
					}
					else if (this.selType != this.SINGLE_SELECTION)
					{
						return this.input_field.hasItem(id);
					}
					return false;
				]]></body>
			</method>


			<method name="setModified">
				<body><![CDATA[
					this._quick_hasModifications = true;
					this.setMessage("");
					this.validate();
					this.raiseChangeEvent();
				]]></body>
			</method>
			
			<method name="isAllowed">
				<parameter name="type" />
				<body><![CDATA[
					var allowed = this.allowedComponents;
					if (allowed == '*') {
						return true;
					}
					var isAllowed = false;
					for (var i=0 ; i<allowed.length && !isAllowed ; i++)
					{
						var allowedType = allowed[i];
						isAllowed = (type == allowedType);
					}
					return isAllowed;
				]]></body>
			</method>


			<method name="formatLabel">
				<parameter name="document" />
				<body><![CDATA[
					var label = this.labelFormat;
					var formattedLabel = '';
					var p = 0;
					while (p < label.length)
					{
						var c = label.charAt(p);

						// find word: search for next character that is not a letter
						var len = 0;
						while (((p + len) < label.length) && ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')))
						{
							c = label.charAt(p + (++len));
						}
						// a word has been found
						if (len > 0)
						{
							var token = label.substr(p, len);
							var tokenRepl = document.component.(@name==token).toString();
							formattedLabel += tokenRepl.length ? tokenRepl : token;
						}
						else
						{
							formattedLabel += c;
							len = 1;
						}
						p += len;
					}
					return formattedLabel;
				]]></body>
			</method>


			<method name="clear">
				<body><![CDATA[
					try
					{
						this.setMessage("");
						this.input_field.empty();
					}
					catch (e)
					{
						wCore.error("clear", [], e);
					}
				]]></body>
			</method>		
			
			<method name="doReset">
				<body><![CDATA[
					try
					{
						this.setMessage("");
						this.input_field.empty();
						var original = this._original_value;
						if (original != null && original != '')
						{
							this.setValueFromID(original);			
						}
						this._quick_hasModifications = false;
					}
					catch (e)
					{
						wCore.error("doReset", [], e);
					}							
				]]></body>
			</method>


			<method name="_removeSelectedItems">
				<body><![CDATA[
					try
					{
						if (this.selType == this.SINGLE_SELECTION)
						{
							if (this.input_field.nbItems == 1)
							{
								this.clear();
								this.setModified();
							}
						}
						else
						{
							var removedCount = this.input_field.removeSelectedItems();
							if (removedCount > 0)
							{
							   this.setModified();
							}
						}
					}
					catch (e)
					{
						wCore.error("_removeSelectedItems", [], e);
					}						
				]]></body>
			</method>

			<method name="onItemMoved">
				<body><![CDATA[
				    this.setModified();
				]]></body>
			</method>

			<method name="getItems">
				<body><![CDATA[
					return this.input_field.getItems();
				]]></body>
			</method>

			<method name="_createNew">
				<body><![CDATA[
					try 
					{
						var parts = this.allowedComponents[0].split(/_/);
						if (this.form && parts.length == 3 && parts[0] == 'modules')
						{
							this.form.createSubDocument(this.name, parts[1], parts[2], null);
						}
					}
					catch (e)
					{
						wCore.error("_createNew", [], e);
					}
				]]></body>
			</method>

			<method name="_openSubForm">
				<parameter name="documentModelName" />
				<body><![CDATA[
					try 
					{
						var parts = documentModelName.split(/_/);
						if (this.form && parts.length == 3 && parts[0] == 'modules')
						{
							this.form.createSubDocument(this.name, parts[1], parts[2], null);
						}
					}
					catch (e)
					{
						wCore.error("_openSubForm", [documentModelName], e);
					}
				]]></body>
			</method>

			<property name="subDocumentParentType">
				<getter><![CDATA[
					return this.getAttribute('parent-type');
				]]></getter>
			</property>

			<method name="_editSelected">
				<body><![CDATA[
					if (this.selType == this.SINGLE_SELECTION)
					{
						var selectedItems = this.getItems();
					}	
					else
					{			
						var selectedItems = this.input_field.getSelectedItems();
					}
					
					if (selectedItems.item.length() == 1)
					{
						var id = selectedItems.item[0].@id;
						var info = wCore.getDocumentInfo(id);
						if (info != null)
						{
							var parts = info.model.split(/[_\/]/);				
							this.form.editSubDocument(this.name, parts[1], parts[2], id);
						}
					}
				]]></body>
			</method>

		</implementation>


		<xbl:content
			xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
			xmlns:xbl="http://www.mozilla.org/xbl">
			<hbox align="center" xbl:inherits="flex,disabled,hidden,width">
				<vbox flex="2">
					<wlistbox orderable="true" anonid="inputField" hideheader="true" xbl:inherits="flex,width,rows,seltype,hideheader,disabled=readonly" style="min-height: 18px !important;">
						<toolbarbutton xbl:inherits="disabled,disabled=readonly" anonid="btnDelete" tooltiptext="&amp;modules.generic.backoffice.Deletelistitems;" image="{IconsBase}/small/shadow/delete.png" oncommand="_removeSelectedItems()" />
					</wlistbox>
					<description anonid="message" hidden="true" />
				</vbox>
				<box anonid="extraButtons" hidden="true" orient="vertical">
					<toolbarbutton xbl:inherits="disabled,disabled=readonly" anonid="btnCreateNew" tooltiptext="&amp;modules.uixul.bo.elementPicker.Create-new;" image="{IconsBase}/small/shadow/add.png" oncommand="_createNew()" />
					<toolbarbutton xbl:inherits="disabled,disabled=readonly" anonid="btnEdit" tooltiptext="&amp;modules.uixul.bo.elementPicker.Edit;" image="{IconsBase}/small/shadow/pencil.png" oncommand="_editSelected()" />
					<spacer flex="1" />
				</box>
				<xbl:children />
			</hbox>

		</xbl:content>


		<handlers>

			<handler event="keypress" keycode="VK_DELETE"><![CDATA[
				if (!this.readonly && !this.getElementById('btnDelete').hidden)
				{
					this._removeSelectedItems(true);
				}
			]]></handler>

		</handlers>


	</binding>


<!--
################################################################################
## wDroppableElementPicker                                                    ##
################################################################################
-->

	<binding id="wDroppableElementPicker" extends="form.wElementPicker#wElementPicker">
		<implementation>
			<field name="_drop_data_flavour" readonly="true">"listitem/component"</field>
			<property name="readonly">
				<getter><![CDATA[
         			return this.hasAttribute('readonly') && this.getAttribute('readonly') == 'true';
				]]></getter>
				<setter><![CDATA[
					if (val)
					{
						this.setAttribute("candrop", 'no-drop');
						this.unregisterDragAndDrop(this);
						this.setAttribute('readonly', 'true');
					}
					else
					{
						this.setAttribute("candrop", this._drop_data_flavour);
						this.registerDragAndDrop(this);
						this.removeAttribute('readonly');
					}
				]]></setter>
			</property>

			<constructor><![CDATA[
				if (!this.readonly)
				{
					this.setAttribute("candrop", this._drop_data_flavour);
					this.registerDragAndDrop(this);
				}
				if (this.selType == this.SINGLE_SELECTION)
				{
					this.input_field.setAttribute('hideupdownbuttons', 'true');
					this.input_field.setAttribute('rows', '1');
				}
			]]></constructor>

			<method name="onDrop">
                <parameter name="element" />
                <parameter name="data" />
                <body><![CDATA[
                	try
                	{
                		wCore.debug('wDroppableElementPicker.onDrop');
	                    var droppedData = wDragAndDrop.getDragDataByFlavour(this._drop_data_flavour, data);
	                    if (droppedData && droppedData.document)
	                    {
							var droppedDocuments = droppedData.document;
							//this.block_change_events = true;
							for (var i=0 ; i<droppedDocuments.length() ; i++)
							{
								var type   = droppedDocuments[i].component.(@name=="type").toString();
								// check if components are allowed or not
								if ( this.isAllowed(type) )
								{
									var id = droppedDocuments[i].component.(@name=="id").toString();
									if (!this.hasDocument(id))
									{
										this.addDocument(droppedDocuments[i]);
									}
								}
								else
								{
									this.setMessage("&modules.uixul.bo.elementPicker.Document-not-allowed;");
								}
							}
							//this.block_change_events = false;
							this.onDocumentDropped(droppedData.document);
						}
					}
					catch (e)
					{
						wCore.error("onDrop", [element, data], e);
					}
                ]]></body>
            </method>

			<method name="onDocumentDropped">
                <parameter name="e4xDocument" />
                <body><![CDATA[
                ]]></body>
            </method>

		</implementation>


		<handlers>

	        <handler event="focus" phase="capturing"><![CDATA[
                this.setAttribute('focused', 'true');
                if (this.form)
                {
                	this.form.onFieldFocus(this);
                }

                // If we can't drop anything in this picker, it is not relevant
                // to display the resources tree.
                if (this.getAttribute('candrop') != 'no-drop')
                {
					var module = this.getModule();
					if (module != null)
					{
						var rscTree = module.getRscTree();
						if (rscTree != null)
						{
							var modelNames = [];
							if (this.allowedComponents.length >= 1)
							{
								for (var i = 0; i < this.allowedComponents.length; i++)
								{								
									var ac = this.allowedComponents[i];
									var re = /^modules_([a-z]+)_([a-z]+)$/;
									re.exec(ac);
									modelNames.push('modules_' + RegExp.$1 + '/' + RegExp.$2);
								}
							}
							module.showRscTree();
							if (modelNames.length >= 1)
							{
								for (var i = 0; i < modelNames.length; i++)
								{
									var modelName = modelNames[i];						
									rscTree.openTreeIndexByModel(modelName);
									var selectedItems = this.input_field.getSelectedItems();
									if (selectedItems.item.length() == 1)
									{
										var id = selectedItems.item[0].@id;
										try
										{
											window.setTimeout(function (_module, _id) {_module.getRscTree()._currentTree.getAttachedComponent().locateDocument(_id); }, 500, module, id);
										}
										catch (e)
										{
											wCore.error("wElementPicker.event.focus", [], e);
										}
									}
								}
							}
						}
					}
				}
            ]]></handler>

		</handlers>

	</binding>

<!--
################################################################################
## wContextualElementPicker                                                   ##
################################################################################
-->

	<binding id="wContextualElementPicker" extends="form.wElementPicker#wDroppableElementPicker">


		<implementation>

			<method name="isAllowedComponent">
				<parameter name="component" />
				<body><![CDATA[
					var pickedParentId = component.(@name=="parentid").toString();
					var newDocumentParentId = this.form.getAttribute('parent-id');
					if (pickedParentId == newDocumentParentId)
					{
						return true;
					}
					else
					{
						return false;
					}
				]]></body>
			</method>

			<method name="onDrop">
                <parameter name="element" />
                <parameter name="data" />
                <body><![CDATA[
                	try
                	{
                		wCore.debug('wDroppableElementPicker.onDrop');
						var droppedDocuments = wDragAndDrop.getDragDataByFlavour(this._drop_data_flavour, data).document;
						//this.block_change_events = true;
						for (var i=0 ; i<droppedDocuments.length() ; i++)
						{
							var type   = droppedDocuments[i].component.(@name=="type").toString();
							// check if components are allowed or not
							if (this.isAllowed(type))
							{
								if (this.isAllowedComponent(droppedDocuments[i].component))
								{
									var id = droppedDocuments[i].component.(@name=="id").toString();
									if (!this.hasDocument(id))
									{
										this.addDocument(droppedDocuments[i]);
									}
								}
								else
								{
									this.setMessage("&modules.uixul.bo.elementPicker.Not-same-parent;");
								}
							}
							else
							{
								this.setMessage("&modules.uixul.bo.elementPicker.Document-not-allowed;");
							}
						}
						//this.block_change_events = false;
					}
					catch (e)
					{
						wCore.error("onDrop", [element, data], e);
					}
                ]]></body>
            </method>

		</implementation>

	</binding>

</bindings>
